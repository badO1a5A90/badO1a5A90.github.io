[{"uri":"https://badO1a5A90.github.io/config/outbound-protocols/blackhole/","title":"Blackhole","tags":[],"description":"Project X 的文档.","content":"Blackhole（黑洞）是一个出站数据协议，它会阻碍所有数据的出站，配合 路由配置 一起使用，可以达到禁止访问某些网站的效果。\nOutboundConfigurationObject  { \u0026#34;response\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; } }  response: ResponseObject\n 配置黑洞的响应数据。\nBlackhole 会在收到待转发数据之后，发送指定的响应数据，然后关闭连接，待转发的数据将被丢弃。 如不指定此项，Blackhole 将直接关闭连接。\n\nResponseObject  { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: \u0026ldquo;http\u0026rdquo; | \u0026ldquo;none\u0026rdquo;\n 当 type 为 \u0026quot;none\u0026quot;（默认值）时，Blackhole 将直接关闭连接。\n当 type 为 \u0026quot;http\u0026quot; 时，Blackhole 会发回一个简单的 HTTP 403 数据包，然后关闭连接。\n"},{"uri":"https://badO1a5A90.github.io/about/","title":"Project X","tags":[],"description":"Project X 的文档.","content":" Project X originates from XTLS protocol, provides a set of network tools such as Xray-core and Xray-flutter.\n Xray-core 是 v2ray-core 的超集，含更好的整体性能和 XTLS 等一系列增强，且完全兼容 v2ray-core 的功能及配置。  只有一个可执行文件，含 ctl 的功能，run 为默认指令 配置上完全兼容，环境变量和 API 对应要改为以 XRAY_ 开头 全平台开放了裸协议的 ReadV 提供完整的 VLESS \u0026amp; Trojan XTLS 支持，均有 ReadV 提供了 XTLS 多种流控模式, 性能一骑绝尘! “配置兼容，整体更好”\n    Xray-flutter 是一个优雅的跨平台图形界面工具.In progress   开发者   It doesn’t matter who we are, what matters is that we will keep riding and not look back. 帮助Xray变得更强  欢迎帮助Xray变得更强！\n 🖥️ 帮助开发和测试 Xray, 提交高质量的 Pull request. 📩 在Github issues或讨论区提交建设性或有意义的issue/讨论. 📝 写下您的使用心得并提交至 Xray 的文档网站. 💬 在Telegram群帮助群友/灌水. \u0026hellip;事实上,每一分给予 Xray 的正能量会让Xray变得更强大   Telegram    Project X 交流群\n 交流群可在底线之上随便水，不要撕逼，没有滥权。 有问题尽管随便问，知道的尽量回答。 禁政治，禁NSFW    Project X 频道\n 发布Project X的最新资讯     致谢   感谢所有人的支持！ 感谢各类脚本、Docker 镜像、客户端支持\u0026hellip;感谢所有帮忙完善生态的大佬们！ 感谢为 Xray 网站和文档添砖加瓦的朋友们. 感谢提出有意义的建议和意见的朋友们. 感谢Telegram群每一位帮助群友的朋友们.   License  Mozilla Public License Version 2.0 Stargazers over time  Project X 的 GitHub 主仓库 Xray-core 已获 1400+ stars；Project X 群人数破2000，频道订阅数 1000\n\n"},{"uri":"https://badO1a5A90.github.io/config/transports/tcp/","title":"TCP","tags":[],"description":"Project X 的文档.","content":"TCP 传输模式是目前推荐使用的传输模式之一.\n可以和各种协议有多种组合模式.\nTcpObject  TcpObject 对应传输配置的 tcpSettings 项。\n{ \u0026#34;acceptProxyProtocol\u0026#34;: false, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; } }  acceptProxyProtocol: true | false\n 仅用于 inbound，指示是否接收 PROXY protocol。\nPROXY protocol 专用于传递请求的真实来源 IP 和端口，若你不了解它，请先忽略该项。\n常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。\n填写 true 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。\n默认值为 false。\nheader: NoneHeaderObject | HttpHeaderobject\n 数据包头部伪装设置，默认值为 NoneHeaderObject。\nTIP\nHTTP 伪装无法被其它 HTTP 服务器（如 Nginx）分流，但可以被 VLESS fallbacks path 分流。\n \nNoneHeaderObject  不进行伪装\n{ \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: \u0026ldquo;none\u0026rdquo;\n 指定不进行伪装\n\nHttpHeaderObject  HTTP 伪装配置必须在对应的入站出站连接上同时配置，且内容必须一致。\n{ \u0026#34;type\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;request\u0026#34;: {}, \u0026#34;response\u0026#34;: {} }  type: \u0026ldquo;http\u0026rdquo;\n 指定进行 HTTP 伪装\nrequest: HTTPRequestObject\n HTTP 请求\nresponse: HTTPResponseObject\n HTTP 响应\n\nHTTPRequestObject  { \u0026#34;version\u0026#34;: \u0026#34;1.1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: [\u0026#34;/\u0026#34;], \u0026#34;headers\u0026#34;: { \u0026#34;Host\u0026#34;: [\u0026#34;www.baidu.com\u0026#34;, \u0026#34;www.bing.com\u0026#34;], \u0026#34;User-Agent\u0026#34;: [ \u0026#34;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\u0026#34;, \u0026#34;Mozilla/5.0 (iPhone; CPU iPhone OS 10_0_2 like Mac OS X) AppleWebKit/601.1 (KHTML, like Gecko) CriOS/53.0.2785.109 Mobile/14A456 Safari/601.1.46\u0026#34; ], \u0026#34;Accept-Encoding\u0026#34;: [\u0026#34;gzip, deflate\u0026#34;], \u0026#34;Connection\u0026#34;: [\u0026#34;keep-alive\u0026#34;], \u0026#34;Pragma\u0026#34;: \u0026#34;no-cache\u0026#34; } }  version: string\n HTTP 版本，默认值为 \u0026quot;1.1\u0026quot;。\nmethod: string\n HTTP 方法，默认值为 \u0026quot;GET\u0026quot;。\npath: [ string ]\n 路径，一个字符串数组。默认值为 [\u0026quot;/\u0026quot;]。当有多个值时，每次请求随机选择一个值。\nheaders: map{ string, [ string ]}\n HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是一个数组。\n每次请求会附上所有的键，并随机选择一个对应的值。默认值见上方示例。\n\nHTTPResponseObject  { \u0026#34;version\u0026#34;: \u0026#34;1.1\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: [\u0026#34;application/octet-stream\u0026#34;, \u0026#34;video/mpeg\u0026#34;], \u0026#34;Transfer-Encoding\u0026#34;: [\u0026#34;chunked\u0026#34;], \u0026#34;Connection\u0026#34;: [\u0026#34;keep-alive\u0026#34;], \u0026#34;Pragma\u0026#34;: \u0026#34;no-cache\u0026#34; } }  version: string\n HTTP 版本，默认值为 \u0026quot;1.1\u0026quot;。\nstatus: string\n HTTP 状态，默认值为 \u0026quot;200\u0026quot;。\nreason: string\n HTTP 状态说明，默认值为 \u0026quot;OK\u0026quot;。\nheaders: map {string, [ string ]}\n HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是一个数组。\n每次请求会附上所有的键，并随机选择一个对应的值。默认值见上方示例。\n"},{"uri":"https://badO1a5A90.github.io/develop/protocols/vless/","title":"VLESS 协议","tags":[],"description":"Project X 的文档.","content":"VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。\n\nIn progress\n"},{"uri":"https://badO1a5A90.github.io/qa/start/","title":"下载和安装中的问题","tags":[],"description":"Project X 的文档.","content":" Q: 我想自己下载安装包, 可是release好多文件, 我要下载哪一个呢?请先使用谷歌搜索您的设备型号, 确认您设备使用的架构, 然后下载对应的版本.  Q: 我在VPS上运行了脚本, 好像安装好了, 可是似乎没反应?/系统服务器不能启动?/我也不知道有没有安装成功?使用命令 \u0026lsquo;journalctl -u xray\u0026rsquo; 查看 xray 的相关日志。\n或者\n终端命令行中执行 \u0026lsquo;xray run -c 您的config.json\u0026rsquo; 文件路径 来查看相关信息\n Q: 配置文件在哪个目录。谢谢!这位同学你可真的是不看文档, 不过因为你很有礼貌, 我可以告诉你在这里有所有文件的安装位置\n "},{"uri":"https://badO1a5A90.github.io/guide/install/","title":"下载安装","tags":[],"description":"Project X 的文档.","content":"平台支持  Xray 在以下平台中可用：\n Windows 7 及之后版本（x86 / amd64 / arm32）； macOS 10.10 Yosemite 及之后版本（amd64）； Linux 2.6.23 及之后版本（x86 / amd64 / arm / arm64 / mips64 / mips / ppc64 / s390x / riscv64）；  包括但不限于 Debian 7 / 8、Ubuntu 12.04 / 14.04 及后续版本、CentOS 7 / 8、Arch Linux 等；   FreeBSD (x86 / amd64)； OpenBSD (x86 / amd64)； Dragonfly BSD (amd64)；  \n下载 Xray  预编译的二进制 ZIP 格式压缩包可在 Github Releases 中找到。\n下载对应平台的压缩包，解压后即可使用。\n\n验证安装包  Xray 提供两种验证方式：\n ZIP 压缩包的 SHA1 / SHA256 摘要: In progress 可复现构建：In progress  \nWindows 安装方式  在 Github Releases 下载适用于 Windows 平台的 ZIP 压缩包，解压后可得到可执行文件 xray.exe，然后通过命令行带参数运行 即可 通过 Scoop 包管理器安装：In progress 通过 Chocolatey 包管理器安装：In progress  \nmacOS 安装方式  在 Github Releases 下载适用于 macOS 平台的 ZIP 压缩包，解压后可得到可执行文件 xray，然后通过命令行带参数运行 即可 通过 Homebrew 包管理器安装：In progress  \nLinux 安装方式  安装脚本    Linux Script\n Xray-install Xray-script    One Click\n ProxySU Xray-agent    Magisk\n Xray4Magisk Xray_For_Magisk    Linux 发行版包管理器  Linux 发行版 Xray 包（可通过发行版相应的包管理器安装）：\n Debian：In progress Arch Linux：In progress  Linuxbrew 包管理器  In progress\n\nDocker 安装方式   teddysun/xray Xray-docker  Docker image 的文件结构   /etc/xray/config.json：配置文件 /usr/bin/xray：Xray 主程序 /usr/local/share/xray/geoip.dat：IP 数据文件 /usr/local/share/xray/geosite.dat：域名数据文件  \n更多更多\u0026hellip;  您可以点击 传送至众多大佬集结区的任意门 获取更多资源\nFAQ In progress\n"},{"uri":"https://badO1a5A90.github.io/develop/intro/","title":"开发手册","tags":[],"description":"Project X 的文档.","content":" 如果您想帮助 Xray 开发, 请详细阅读本章节中的内容 编译 Xray 支持各种平台, 您可以在多种平台上自行进行交叉编译.\n请点击编译以查看具体编译相关内容\n 设计思路 Xray 内核提供了一个平台，在其之上可以进二次开发 这个章节阐述了Xray的设计目标和架构.\n请点击设计思路以了解Xray的设计目标和架构.\n 开发规范 这个章节阐述了获取代码,进行开发,提交PR的流程中需要遵循的准则, 以及相关的编码规范\n请点击开发规范查看Xray开发中应遵循的准则.\n  \n协议详解 Xray 用到了很多种协议, 您可以通过各种途径获得协议的详细描述.\n请点击协议详解以查看相关协议的详细剖析\n  "},{"uri":"https://badO1a5A90.github.io/config/log/","title":"日志配置","tags":[],"description":"Project X 的文档.","content":"日志配置，控制 Xray输出日志的方式.\nXray 有两种日志, 访问日志和错误日志, 你可以分别配置两种日志的输出方式.\nLogObject  LogObject 对应配置文件的 log 项。\n{ \u0026#34;log\u0026#34;: { \u0026#34;access\u0026#34;: \u0026#34;文件地址\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;文件地址\u0026#34;, \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34; } }  access: string\n 访问日志的文件地址，其值是一个合法的文件地址，如\u0026quot;/var/log/Xray/access.log\u0026quot;（Linux）或者\u0026quot;C:\\\\Temp\\\\Xray\\\\_access.log\u0026quot;（Windows）。当此项不指定或为空值时，表示将日志输出至 stdout。\n 特殊值none，即关闭 access log。  error: string\n 错误日志的文件地址，其值是一个合法的文件地址，如\u0026quot;/var/log/Xray/error.log\u0026quot;（Linux）或者\u0026quot;C:\\\\Temp\\\\Xray\\\\_error.log\u0026quot;（Windows）。当此项不指定或为空值时，表示将日志输出至 stdout。\n 特殊值none，即关闭 error log。  loglevel: \u0026ldquo;debug\u0026rdquo; | \u0026ldquo;info\u0026rdquo; | \u0026ldquo;warning\u0026rdquo; | \u0026ldquo;error\u0026rdquo; | \u0026ldquo;none\u0026rdquo;\n error 日志的级别, 指示 error 日志需要记录的信息. 默认值为 \u0026quot;warning\u0026quot;。\n \u0026quot;debug\u0026quot;：调试程序时用到的输出信息。同时包含所有 \u0026quot;info\u0026quot; 内容。 \u0026quot;info\u0026quot;：运行时的状态信息等，不影响正常使用。同时包含所有 \u0026quot;warning\u0026quot; 内容。 \u0026quot;warning\u0026quot;：发生了一些并不影响正常运行的问题时输出的信息，但有可能影响用户的体验。同时包含所有 \u0026quot;error\u0026quot; 内容。 \u0026quot;error\u0026quot;：Xray 遇到了无法正常运行的问题，需要立即解决。 \u0026quot;none\u0026quot;：不记录任何内容。  "},{"uri":"https://badO1a5A90.github.io/develop/intro/compile/","title":"编译","tags":[],"description":"Project X 的文档.","content":"前序工作  Xray 使用 Golang 作为主要编程语言。\n 下载 Golang: Downloads 安装 Golang: install  important请使用 Golang 1.15 以上版本。\n \n编译  拉取 Xray 源代码和依赖  在安装了git的环境下, 只需要执行以下命令即可clone一份完整的Xray-core代码:\ngit clone https://github.com/XTLS/Xray-core.git \n注意事项  在无法正常访问 Google 的网络环境，依赖可能无法被正常拉取，可以通过各种手段代理解决.\n比如可以通过设置 GOPROXY：\ngo env -w GOPROXY=https://goproxy.io,direct \n手工编译  important本小节的命令需要在 Xray 项目根目录内运行。\n 在 Linux 环境下, 只需执行以下命令, 即可在当前目录下生成刚构建的 xray 可执行文件。\nCGO_ENABLED=0 go build -o xray -trimpath -ldflags \u0026#34;-s -w -buildid=\u0026#34; ./main \n交叉编译  构建其他 CPU 架构、其他系统（Windows/macOS）的可执行文件需要设置 GOOS 和 GOARCH 两个环境变量为目标平台/架构.\n可以参考 Golang 相关文档 比如Building Windows Go programs on Linux。\n如下面代码即可以构建可运行在 Windows 64 位系统的 xray.exe 可执行文件：\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o xray.exe -trimpath -ldflags \u0026#34;-s -w -buildid=\u0026#34; ./main  TIP\n执行 go tool dist list 可以查看所有支持的系统与架构。 某些架构还需要控制其它环境变量，如 arm 的 GOARM，用于设置运行时 CPU 浮点协处理器的版本。\n "},{"uri":"https://badO1a5A90.github.io/config/api/","title":"API接口","tags":[],"description":"Project X 的文档.","content":"API接口配置提供了一些基于 gRPC的 API 接口供远程调用。\n可以通过api配置模块开启接口. 当api配置开启时，Xray 会自建一个出站代理， 须手动将所有的 API 入站连接通过 路由规则配置 指向这一出站代理。\n请参考本节中的相关配置\n大多数用户并不会用到此 API，新手可以直接忽略这一项。\n ApiObject  ApiObject 对应配置文件的 api 项。\n{ \u0026#34;api\u0026#34;: { \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;services\u0026#34;: [ \u0026#34;HandlerService\u0026#34;, \u0026#34;LoggerService\u0026#34;, \u0026#34;StatsService\u0026#34; ] } }  tag: string\n 出站代理标识。\nservices: [string]\n 开启的 API 列表，可选的值见 API 列表。\n\n相关配置  可以在 inbounds 配置中增加一个 api 的 inbound\n\u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 10085, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ] 在路由配置中增加针对api inbound的路由规则\n\u0026#34;routing\u0026#34;: { \u0026#34;settings\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;strategy\u0026#34;: \u0026#34;rules\u0026#34; } \n支持的 API 列表  HandlerService 一些对于入站出站代理进行修改的 API，可用的功能如下：\n 添加一个新的入站代理； 添加一个新的出站代理； 删除一个现有的入站代理； 删除一个现有的出站代理； 在一个入站代理中添加一个用户（仅支持 VMess、VLESS、Trojan）； 在一个入站代理中删除一个用户（仅支持 VMess、VLESS、Trojan）；  LoggerService 支持对内置 Logger 的重启，可配合 logrotate 进行一些对日志文件的操作。\nStatsService 内置的数据统计服务，详见 统计信息。\n"},{"uri":"https://badO1a5A90.github.io/config/outbound-protocols/dns/","title":"DNS","tags":[],"description":"Project X 的文档.","content":"DNS 是一个出站协议，主要用于拦截和转发 DNS 查询。\n此出站协议只能接收 DNS 流量（包含基于 UDP 和 TCP 协议的查询），其它类型的流量会导致错误。\n在处理 DNS 查询时，此出站协议会将 IP 查询（即 A 和 AAAA）转发给内置的 DNS 服务器。其它类型的查询流量将被转发至它们原本的目标地址。\nOutboundConfigurationObject  { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;1.1.1.1\u0026#34;, \u0026#34;port\u0026#34;: 53 }  network: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo;\n 修改 DNS 流量的传输层协议，可选的值有 \u0026quot;tcp\u0026quot; 和 \u0026quot;udp\u0026quot;。当不指定时，保持来源的传输方式不变。\naddress: address\n 修改 DNS 服务器地址。当不指定时，保持来源中指定的地址不变。\nport: number\n 修改 DNS 服务器端口。当不指定时，保持来源中指定的端口不变。\n\nDNS配置实例  In progress\n"},{"uri":"https://badO1a5A90.github.io/config/inbound-protocols/dokodemo/","title":"Dokodemo door","tags":[],"description":"Project X 的文档.","content":"Dokodemo door（任意门）可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。\nInboundConfigurationObject  { \u0026#34;address\u0026#34;: \u0026#34;8.8.8.8\u0026#34;, \u0026#34;port\u0026#34;: 53, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;timeout\u0026#34;: 0, \u0026#34;followRedirect\u0026#34;: false, \u0026#34;userLevel\u0026#34;: 0 }  address: address\n 将流量转发到此地址。可以是一个 IP 地址，形如 \u0026quot;1.2.3.4\u0026quot;，或者一个域名，形如 \u0026quot;xray.com\u0026quot;。字符串类型。\n当 followRedirect（见下文）为 true 时，address 可为空。\nport: number\n 将流量转发到目标地址的指定端口，范围 [1, 65535]，数值类型。必填参数。\nnetwork: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo; | \u0026ldquo;tcp,udp\u0026rdquo;\n 可接收的网络协议类型。比如当指定为 \u0026quot;tcp\u0026quot; 时，仅会接收 TCP 流量。默认值为 \u0026quot;tcp\u0026quot;。\ntimeout: number\n 连接空闲的时间限制。单位为秒。默认值为 300。处理一个连接时，如果在 timeout 时间内，没有任何数据被传输，则中断该连接。\nfollowRedirect: true | false\n 当值为 true 时，dokodemo-door 会识别出由 iptables 转发而来的数据，并转发到相应的目标地址。\n可参考 传输配置 中的 tproxy 设置。\nuserLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\n透明代理配置样例  "},{"uri":"https://badO1a5A90.github.io/develop/protocols/vmess/","title":"VMess 协议","tags":[],"description":"Project X 的文档.","content":"VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。\n\n版本  当前版本号为 1。\n\n依赖  底层协议  VMess 是一个基于 TCP 的协议，所有数据使用 TCP 传输。\n\n用户 ID  ID 等价于 UUID，是一个 16 字节长的随机数，它的作用相当于一个令牌（Token）。 一个 ID 形如：de305d54-75b4-431b-adb2-eb6b9e546014，几乎完全随机，可以使用任何的 UUID 生成器来生成，比如这个。\n用户 ID 可在配置文件中指定。\n\n函数   MD5: MD5 函数  输入参数为任意长度的 byte 数组 输出为一个 16 byte 的数组   HMAC: HMAC 函数  输入参数为：  H：散列函数 K：密钥，任意长度的 byte 数组 M：消息，任意长度的 byte 数组     Shake: SHA3-Shake128 函数  输入参数为任意长度的字符串 输出为任意长度的字符串    \n通讯过程  VMess 是一个无状态协议，即客户端和服务器之间不需要握手即可直接传输数据，每一次数据传输对之前和之后的其它数据传输没有影响。\nVMess 的客户端发起一次请求，服务器判断该请求是否来自一个合法的客户端。如验证通过，则转发该请求，并把获得的响应发回给客户端。\nVMess 使用非对称格式，即客户端发出的请求和服务器端的响应使用了不同的格式。\n\n客户端请求     16 字节 X 字节 余下部分     认证信息 指令部分 数据部分    \n认证信息  认证信息是一个 16 字节的哈希（hash）值，它的计算方式如下：\n H = MD5 K = 用户 ID (16 字节) M = UTC 时间，精确到秒，取值为当前时间的前后 30 秒随机值(8 字节, Big Endian) Hash = HMAC(H, K, M)  \n指令部分  指令部分经过 AES-128-CFB 加密：\n Key：MD5(用户 ID + []byte(\u0026lsquo;c48619fe-8f02-49e0-b9e9-edf763e17e21\u0026rsquo;)) IV：MD5(X + X + X + X)，X = []byte(认证信息生成的时间) (8 字节, Big Endian)     1 字节 16 字节 16 字节 1 字节 1 字节 4 位 4 位 1 字节 1 字节 2 字节 1 字节 N 字节 P 字节 4 字节     版本号 Ver 数据加密 IV 数据加密 Key 响应认证 V 选项 Opt 余量 P 加密方式 Sec 保留 指令 Cmd 端口 Port 地址类型 T 地址 A 随机值 校验 F    选项 Opt 细节：（当某一位为 1 时，表示该选项启用）\n   0 1 2 3 4 5 6 7     X X X X X M R S    其中：\n 版本号 Ver：始终为 1； 数据加密 IV：随机值； 数据加密 Key：随机值； 响应认证 V：随机值； 选项 Opt：  S (0x01)：标准格式的数据流（建议开启）； R (0x02)：客户端期待重用 TCP 连接（Xray 2.23+ 弃用）；  只有当 S 开启时，这一项才有效；   M (0x04)：开启元数据混淆（建议开启）；  只有当 S 开启时，这一项才有效； 当其项开启时，客户端和服务器端需要分别构造两个 Shake 实例，分别为 RequestMask = Shake(请求数据 IV), ResponseMask = Shake(响应数据 IV)。   X：保留   余量 P：在校验值之前加入 P 字节的随机值； 加密方式：指定数据部分的加密方式，可选的值有：  0x00：AES-128-CFB； 0x01：不加密； 0x02：AES-128-GCM； 0x03：ChaCha20-Poly1305；   指令 Cmd：  0x01：TCP 数据； 0x02：UDP 数据；   端口 Port：Big Endian 格式的整型端口号； 地址类型 T：  0x01：IPv4 0x02：域名 0x03：IPv6   地址 A：  当 T = 0x01 时，A 为 4 字节 IPv4 地址； 当 T = 0x02 时，A 为 1 字节长度（L） + L 字节域名； 当 T = 0x03 时，A 为 16 字节 IPv6 地址；   校验 F：指令部分除 F 外所有内容的 FNV1a hash；  \n数据部分  当 Opt(S) 开启时，数据部分使用此格式。实际的请求数据被分割为若干个小块，每个小块的格式如下。服务器校验完所有的小块之后，再按基本格式的方式进行转发。\n   2 字节 L 字节     长度 L 数据包    其中：\n 长度 L：Big Endian 格式的整型，最大值为 2^14；  当 Opt(M) 开启时，L 的值 = 真实值 xor Mask。Mask = (RequestMask.NextByte() \u0026laquo; 8) + RequestMask.NextByte()；   数据包：由指定的加密方式加密过的数据包；  在传输结束之前，数据包中必须有实际数据，即除了长度和认证数据之外的数据。当传输结束时，客户端必须发送一个空的数据包，即 L = 0（不加密） 或认证数据长度（有加密），来表示传输结束。\n按加密方式不同，数据包的格式如下：\n 不加密：  L 字节：实际数据；   AES-128-CFB：整个数据部分使用 AES-128-CFB 加密  4 字节：实际数据的 FNV1a hash； L - 4 字节：实际数据；   AES-128-GCM：Key 为指令部分的 Key，IV = count (2 字节) + IV (10 字节)。count 从 0 开始递增，每个数据包加 1；IV 为 指令部分 IV 的第 3 至第 12 字节。  L - 16 字节：实际数据； 16 字节：GCM 认证信息   ChaCha20-Poly1305：Key = MD5(指令部分 Key) + MD5(MD5(指令部分 Key))，IV = count (2 字节) + IV (10 字节)。count 从 0 开始递增，每个数据包加 1；IV 为 指令部分 IV 的第 3 至第 12 字节。  L - 16 字节：实际数据； 16 字节：Poly1305 认证信息    \n服务器应答  应答头部数据使用 AES-128-CFB 加密，IV 为 MD5(数据加密 IV)，Key 为 MD5(数据加密 Key)。实际应答数据视加密设置不同而不同。\n   1 字节 1 字节 1 字节 1 字节 M 字节 余下部分     响应认证 V 选项 Opt 指令 Cmd 指令长度 M 指令内容 实际应答数据    其中：\n 响应认证 V：必须和客户端请求中的响应认证 V 一致； 选项 Opt：  0x01：服务器端准备重用 TCP 连接（Xray 2.23+ 弃用）；   指令 Cmd：  0x01：动态端口指令   实际应答数据：  如果请求中的 Opt(S) 开启，则使用标准格式，否则使用基本格式。 格式均和请求数据相同。  当 Opt(M) 开启时，长度 L 的值 = 真实值 xor Mask。Mask = (ResponseMask.NextByte() \u0026laquo; 8) + ResponseMask.NextByte()；      \n动态端口指令     1 字节 2 字节 16 字节 2 字节 1 字节 1 字节     保留 端口 Port 用户 ID AlterID 用户等级 有效时间 T    其中：\n 端口 Port：Big Endian 格式的整型端口号； 有效时间 T：分钟数；  客户端在收到动态端口指令时，服务器已开放新的端口用于通信，这时客户端可以将数据发往新的端口。在 T 分钟之后，这个端口将失效，客户端必须重新使用主端口进行通信。\n\n注释   为确保向前兼容性，所有保留字段的值必须为 0。  "},{"uri":"https://badO1a5A90.github.io/config/transports/websocket/","title":"WebSocket","tags":[],"description":"Project X 的文档.","content":"使用标准的 WebSocket 来传输数据。\nWebSocket 连接可以被其它 HTTP 服务器（如 Nginx）分流，也可以被 VLESS fallbacks path 分流。\nTIP\nWebsocket 会识别 HTTP 请求的 X-Forwarded-For 头来覆写流量的源地址，优先级高于 PROXY protocol。\n WebSocketObject WebSocketObject 对应传输配置的 wsSettings 项。\n{ \u0026#34;acceptProxyProtocol\u0026#34;: false, \u0026#34;path\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Host\u0026#34;: \u0026#34;xray.com\u0026#34; } }  acceptProxyProtocol: true | false\n 仅用于 inbound，指示是否接收 PROXY protocol。\nPROXY protocol 专用于传递请求的真实来源 IP 和端口，若你不了解它，请先忽略该项。\n常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。\n填写 true 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。\npath string\n WebSocket 所使用的 HTTP 协议路径，默认值为 \u0026quot;/\u0026quot;。\nheaders: map {string: string}\n 自定义 HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是字符串。\n默认值为空。\n"},{"uri":"https://badO1a5A90.github.io/develop/protocols/","title":"协议详解","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了 Xray 中所使用协议的详细剖析 \n vless\n VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 vmess\n VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 Mux.Cool\n Mux.Cool 协议是一个多路复用传输协议，用于在一条已建立的数据流中传输多个各自独立的数据流。 mKCP\n mKCP 是流式传输协议，由 KCP 协议修改而来，可以按顺序传输任意的数据流。\n"},{"uri":"https://badO1a5A90.github.io/guide/","title":"快速入门","tags":[],"description":"Project X 的文档.","content":" 这个章节将告诉您如何用最简单的方式获得Xray,并且开始使用Xray. 下载安装 Xray支持各种平台,并且您可以从多种渠道和方式获得Xray的各种版本.\n请点击如何下载安装Xray以获取Xray\n 配置运行 下载并安装Xray后，只需对他进行配置即可使用.\n请点击如何配置运行Xray以学习最简单的配置方式.\n 命令参数 Xray有多种命令和参数可用,因此变得灵活和强大.\n请点击Xray的命令参数查看Xray的更多命令和参数用法.\n  \n使用文档 您正在查看的是 Project X 的文档网站. 您可以了解更多网站的使用方式, 或是帮助我们改进文档质量.\n请点击使用文档进一步查看相关内容\n    "},{"uri":"https://badO1a5A90.github.io/develop/intro/design/","title":"设计思路","tags":[],"description":"Project X 的文档.","content":"设计目标   Xray 内核提供了一个平台，支持必要的网络代理功能，在其之上可以进二次开发，以提供更好的用户体验； 以跨平台为首要原则，以减少二次开发的成本；  \n架构  内核分为三层：应用层、代理层和传输层。\n每一层内包含数个模块，模块间互相独立，同类型的模块可无缝替换。\n\n应用层  应用层包含一些代理层中常用的功能，这些功能被抽象出来，以便在不同的代理模块中复用。\n应用层的模块应为纯软件实现，与硬件或平台相关的技术无关。\n重要模块列表：\n Dispatcher: 用于把入站代理所接收到的数据，传送给出站代理； Router: 路由模块，详见 路由配置； DNS: 内置的 DNS 服务器模块； Proxy Manager: 代理管理器；  \n代理层  代理层分为两部分：入站代理（Inbound Proxy）和出站代理（Outbound Proxy）。\n两部分相互独立，入站代理不依赖于某个特定的出站代理，反之亦然。\n入站代理   实现 proxy.Inbound 接口；  出站代理   实现 proxy.Outbound 接口；  \n传输层  传输层提供一些网络数据传输相关的工具模块。\n"},{"uri":"https://badO1a5A90.github.io/qa/config/","title":"配置和运行时的问题","tags":[],"description":"Project X 的文档.","content":" Q: 为什么windows下只有一个可执行程序? 我想要隐藏执行, 嘤嘤嘤.A1: 方式很多,如: 建立一个hiderun.vbs文件,放在xray.exe同一目录 编辑内容为\nCreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;xray.exe\u0026#34;,0 运行此vbs即可, 然后放个快捷方式到shell:startup里面，就可以开机启动了\n A2: 也可以通过创建window服务/计划任务等方式实现,亦可借助一些专门的后台运行的工具(不太必要)\n A3: CHP (Create Hidden Process)\n A4: 用winsw可以将xray-core添加为Win的系统服务，开机自动运行，不需要手动隐藏窗口。\n A5: 写一个bat开机启动\n@echo off if \u0026#34;%1\u0026#34; == \u0026#34;h\u0026#34; goto begin mshta vbscript:createobject(\u0026#34;wscript.shell\u0026#34;).run(\u0026#34;%~nx0 h\u0026#34;,0)(window.close)\u0026amp;\u0026amp;exit :begin D:/Xray run -c D:/Xray.json ` \n \nQ: 无法用做Tor前置代理 #66关闭 sniffing 再试试.\n \nQ: 如何自定义.dat文件的文件位置?设置环境变量 XRAY_LOCATION_ASSET 的值\n \nQ: 为什么我配置了SSL证书但不可用? 检查证书权限 使用 fullchain 证书   \nQ: 我以前用gfw列表, 我现在用Xray怎么进行分流呢?使用geo*.dat, 并且合理配置路由规则.\n \nQ: 我还是上一题的提问者, 那么我如何使用dat数据文件和配置路由规则达到国内走直连,其他走代理的目的呢?等待好心人写一篇小小白白话文\n \n"},{"uri":"https://badO1a5A90.github.io/guide/config/","title":"配置运行","tags":[],"description":"Project X 的文档.","content":"下载并安装 了 Xray 之后，您需要对它进行一下配置。\n为了演示，这里只介绍简单的配置方式.\n如需配置更复杂的功能，请参考更详细的 配置文件 中相关说明。\n\n服务端配置  你需要一台防火墙外的服务器，来运行服务器端的 Xray。配置如下：\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 10086, // 服务器监听端口 \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;b831381d-6324-4d53-ad4f-8cda48b30811\u0026#34; } ] } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34; } ] } 服务器的配置中需要确保 id 和端口与客户端一致，就可以正常连接了。\n\n客户端配置  在你的 PC（或手机）中，需要用以下配置运行 Xray ：\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 1080, // SOCKS 代理端口，在浏览器中需配置代理并指向这个端口 \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;udp\u0026#34;: true } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;server\u0026#34;, // 服务器地址，请修改为你自己的服务器 ip 或域名 \u0026#34;port\u0026#34;: 10086, // 服务器端口 \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;b831381d-6324-4d53-ad4f-8cda48b30811\u0026#34; } ] } ] } }, { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;direct\u0026#34; } ], \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;IPOnDemand\u0026#34;, \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [\u0026#34;geoip:private\u0026#34;], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34; } ] } } 上述配置唯一要更改的地方是你的服务器 IP，配置中已注明。上述配置会把除局域网（比如访问路由器）以外的所有流量转发至你的服务器。\n\n运行   在 Windows 和 macOS 中，配置文件通常是 Xray 同目录下的 config.json 文件。  直接运行 Xray 或 Xray.exe 即可。   在 Linux 中，配置文件通常位于 /etc/Xray/ 或 /usr/local/etc/Xray/ 目录下。  运行 xray run -c /etc/Xray/config.json 或使用 systemd 等工具将 Xray 作为服务在后台运行。    更多详细的说明可以参考 配置文档 和 使用心得。\n"},{"uri":"https://badO1a5A90.github.io/config/transports/domainsocket/","title":"Domain Socket","tags":[],"description":"Project X 的文档.","content":" important推荐写到 inbounds 的 listen 处，传输方式可选 TCP、WebSocket、HTTP/2.\n未来这里的 DomainSocket 可能会被弃用。\n Domain Socket 使用标准的 Unix domain socket 来传输数据。\n它的优势是使用了操作系统内建的传输通道，而不会占用网络缓存。 理论上相比起本地环回网络（local loopback）来说，Domain socket 速度略快一些。\n目前仅可用于支持 Unix domain socket 的平台，如 Linux 和 macOS。在 Windows 10 Build 17036 前不可用。\n如果指定了 domain socket 作为传输方式，在入站出站代理中配置的端口和 IP 地址将会失效，所有的传输由 domain socket 取代。\nDomainSocketObject  DomainSocketObject 对应传输配置的 dsSettings 项。\n{ \u0026#34;path\u0026#34;: \u0026#34;/path/to/ds/file\u0026#34;, \u0026#34;abstract\u0026#34;: false, \u0026#34;padding\u0026#34;: false }  path: string\n 一个合法的文件路径。 important在运行 Xray 之前，这个文件必须不存在。\n abstract: true | false\n 是否为 abstract domain socket，默认值 false。\n padding: true | false\n abstract domain socket 是否带 padding，默认值 false。\n"},{"uri":"https://badO1a5A90.github.io/config/outbound-protocols/freedom/","title":"Freedom","tags":[],"description":"Project X 的文档.","content":"Freedom 是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。\nOutboundConfigurationObject  { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;redirect\u0026#34;: \u0026#34;127.0.0.1:3366\u0026#34;, \u0026#34;userLevel\u0026#34;: 0 }  domainStrategy: \u0026ldquo;AsIs\u0026rdquo; | \u0026ldquo;UseIP\u0026rdquo; | \u0026ldquo;UseIPv4\u0026rdquo; | \u0026ldquo;UseIPv6\u0026rdquo;\n 在目标地址为域名时, 配置相应的值, Freedom 的行为模式如下:\n \u0026quot;AsIs\u0026quot;: Freedom 通过系统DNS服务器解析获取IP, 向此域名发出连接. \u0026quot;UseIP\u0026quot;、\u0026quot;UseIPv4\u0026quot; 和 \u0026quot;UseIPv6\u0026quot;: Xray 使用内置 DNS 服务器解析获取IP, 向此域名发出连接. 默认值为 \u0026quot;AsIs\u0026quot;。   TIP 1\n当使用 \u0026quot;UseIP\u0026quot; 模式，并且出站连接配置 中指定了 sendThrough 时，Freedom 会根据 sendThrough 的值自动判断所需的 IP 类型，IPv4 或 IPv6。\n TIP 2\n当使用 \u0026quot;UseIPv4\u0026quot; 或 \u0026quot;UseIPv6\u0026quot; 模式时，Freedom 会只使用对应的 IPv4 或 IPv6 地址。当 sendThrough 指定了不匹配的本地地址时，将导致连接失败。\n redirect: address_port\n Freedom 会强制将所有数据发送到指定地址（而不是 inbound 指定的地址）。\n其值为一个字符串，样例：\u0026quot;127.0.0.1:80\u0026quot;，\u0026quot;:1234\u0026quot;。\n当地址不指定时，如 \u0026quot;:443\u0026quot;，Freedom 不会修改原先的目标地址。 当端口为 0 时，如 \u0026quot;xray.com: 0\u0026quot;，Freedom 不会修改原先的端口。\nuserLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n"},{"uri":"https://badO1a5A90.github.io/config/inbound-protocols/http/","title":"HTTP","tags":[],"description":"Project X 的文档.","content":"HTTP 协议。\nimportanthttp 协议没有对传输加密，不适宜经公网中传输，更容易成为被人用作攻击的肉鸡。\nhttp inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n TIP 1\nhttp proxy 只能代理 tcp 协议，udp 系的协议均不能通过。\n TIP 2\n在 Linux 中使用以下环境变量即可在当前 session 使用全局 HTTP 代理（很多软件都支持这一设置，也有不支持的）。\n export http_proxy=http://127.0.0.1:8080/ (地址须改成你配置的 HTTP 入站代理地址) export https_proxy=$http_proxy   InboundConfigurationObject  { \u0026#34;timeout\u0026#34;: 0, \u0026#34;accounts\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ], \u0026#34;allowTransparent\u0026#34;: false, \u0026#34;userLevel\u0026#34;: 0 }  timeout: number\n 连接空闲的时间限制。单位为秒。默认值为 300, 0 表示不限时。\n处理一个连接时，如果在 timeout 时间内，没有任何数据被传输，则中断该连接。\naccounts: [AccountObject]\n 一个数组，数组中每个元素为一个用户帐号。默认值为空。\n当 accounts 非空时，HTTP 代理将对入站连接进行 Basic Authentication 验证。\nallowTransparent: true | false\n 当为 true 时，会转发所有 HTTP 请求，而非只是代理请求。\nTIP\n若配置不当，开启此选项会导致死循环。\n userLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\nAccountObject  { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\n"},{"uri":"https://badO1a5A90.github.io/develop/protocols/muxcool/","title":"Mux.Cool 协议","tags":[],"description":"Project X 的文档.","content":"Mux.Cool 协议是一个多路复用传输协议，用于在一条已建立的数据流中传输多个各自独立的数据流。\n\n版本  当前版本是 1 Beta。\n\n依赖  底层协议  Mux.Cool 必须运行在一个已建立的可靠数据流之上。\n\n通讯过程  一个 Mux.Cool 连接中可传输若干个子连接，每个子连接有一个独立的 ID 和状态。传输过程由帧（Frame）组成，每一帧用于传输一个特定的子连接的数据。\n\n客户端行为  当有连接需求时并且没有现有可用的连接时，客户端向服务器发起一个新连接，以下称为“主连接”。\n 一个主连接可用于发送若干个子连接。客户端可自主决定主连接可承载的子连接数量。 对于一个新的子连接，客户端必须发送状态New以通知服务器建立子连接，然后使用状态Keep来传送数据。 当子连接结束时，客户端发送End状态来通知服务器关闭子连接。 客户端可自行决定何时关闭主连接，但必须确定服务器也同时保持连接。 客户端可使用 KeepAlive 状态来避免服务器关闭主连接。  \n服务器端行为  当服务器端接收到新的子连接时，服务器应当按正常的连接来处理。\n 当收到状态End时，服务器端可以关闭对目标地址的上行连接。 在服务器的响应中，必须使用与请求相同的 ID 来传输子连接的数据。 服务器不能使用New状态。 服务器可使用 KeepAlive 状态来避免客户端关闭主连接。  \n传输格式  Mux.Cool 使用对称传输格式，即客户端和服务器发送和接收相同格式的数据。\n\n帧格式     2 字节 L 字节 X 字节     元数据长度 L 元数据 额外数据    \n元数据  元数据有若干种类型，由状态 S 来区分。所有类型的元数据都包含 ID 和 Opt 两项，其含义为：\n ID: 子连接的唯一标识 Opt:  D(0x01): 有额外数据    当选项 Opt(D) 开启时，额外数据格式如下：\n   2 字节 L 字节     长度 L 数据    \n新建子连接 (New)     2 字节 1 字节 1 字节 1 字节 2 字节 1 字节 X 字节     ID 0x01 选项 Opt 网络类型 N 端口 地址类型 T 地址 A    其中：\n 网络类型 N：  0x01：TCP，表示当前子连接的流量应当以 TCP 的方式发送至目标。 0x02：UDP，表示当前子连接的流量应当以 UDP 的方式发送至目标。   地址类型 T：  0x01：IPv4 0x02：域名 0x03：IPv6   地址 A：  当 T = 0x01 时，A 为 4 字节 IPv4 地址； 当 T = 0x02 时，A 为 1 字节长度（L） + L 字节域名； 当 T = 0x03 时，A 为 16 字节 IPv6 地址；    在新建子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。\n\n保持子连接 (Keep)     2 字节 1 字节 1 字节     ID 0x02 选项 Opt    在保持子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。\n\n关闭子连接 (End)     2 字节 1 字节 1 字节     ID 0x03 选项 Opt    在保持子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。\n\n保持连接 (KeepAlive)     2 字节 1 字节 1 字节     ID 0x04 选项 Opt    在保持连接时:\n 若 Opt(D) 开启，则这一帧所带的数据必须被丢弃。 ID 可为随机值。  \n应用  Mux.Cool 协议与底层协议无关，理论上可以使用任何可靠的流式连接来传输 Mux.Cool 的协议数据。\n在目标导向的协议如 Shadowsocks 和 VMess 协议中，连接建立时必须包含一个指定的地址。\n为了保持兼容性，Mux.Cool 协议指定地址为“v1.mux.cool”。即当主连接的目标地址与之匹配时，则进行 Mux.Cool 方式的转发，否则按传统方式进行转发。\n"},{"uri":"https://badO1a5A90.github.io/config/dns/","title":"内置DNS服务器","tags":[],"description":"Project X 的文档.","content":"DNS 服务器  如果为 Xray 配置了 DNS 服务器模块，主要有两大用途：\n  在路由阶段, 解析域名为 IP, 并且根据域名解析得到的 IP 进行规则匹配以分流. 是否解析域名及分流和路由配置模块中\u0026quot;domainStrategy\u0026quot;的值有关, 只有在设置以下两种值时,才会使用内置 DNS 服务器进行 DNS 查询:\n \u0026ldquo;IPIfNonMatch\u0026rdquo;, 请求一个域名时，进行路由里面的 domain 进行匹配，若无法匹配到结果，则对这个域名使用内置 DNS 服务器进行 DNS 查询，并且使用查询返回的 IP 地址再重新进行 IP 路由匹配。 \u0026ldquo;IPOnDemand\u0026rdquo;, 当匹配时碰到任何基于 IP 的规则，将域名立即解析为 IP 进行匹配。    解析目标地址进行连接。\n 如 在 freedom 协议的 outbound 中，将domainStrategy 设置为 UseIP, 由此 outbound 发出的请求, 会先将域名通过内置服务器解析成 IP, 然后进行连接    TIP 1\n内置 DNS 服务器所发出的 DNS 查询请求，会自动根据路由配置进行转发。\n TIP 2\n只支持最基本的 IP 查询（A 和 AAAA 记录）。\n \nDNS 处理流程  DNS 服务器配置模块可以配置多个DNS服务器, 并且指定优先匹配列表.\n 查询的域名与某个 DNS 服务器指定的域名列表匹配时，Xray 会优先使用这个 DNS 服务器进行查询 无匹配时, 按从上往下的顺序进行查询 只返回匹配 expectIPs 的 IP 列表。  DNS 服务器的处理流程示意图如下：\n\nDnsObject  DnsObject 对应配置文件的 dns 项。\n{ \u0026#34;dns\u0026#34;: { \u0026#34;hosts\u0026#34;: { \u0026#34;baidu.com\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;servers\u0026#34;: [ \u0026#34;8.8.8.8\u0026#34;, \u0026#34;8.8.4.4\u0026#34;, { \u0026#34;address\u0026#34;: \u0026#34;1.2.3.4\u0026#34;, \u0026#34;port\u0026#34;: 5353, \u0026#34;domains\u0026#34;: [\u0026#34;domain:xray.com\u0026#34;], \u0026#34;expectIPs\u0026#34;: [\u0026#34;geoip:cn\u0026#34;] }, \u0026#34;localhost\u0026#34; ], \u0026#34;clientIp\u0026#34;: \u0026#34;1.2.3.4\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;dns_inbound\u0026#34; } }  hosts: map{string: address}\n 静态 IP 列表，其值为一系列的 \u0026ldquo;域名\u0026rdquo;: \u0026ldquo;地址\u0026rdquo;。其中地址可以是 IP 或者域名。在解析域名时，如果域名匹配这个列表中的某一项:\n 当该项的地址为 IP 时，则解析结果为该项的 IP 当该项的地址为域名时，会使用此域名进行 IP 解析，而不使用原始域名。  域名的格式有以下几种形式：\n 纯字符串：当此字符串完整匹配目标域名时，该规则生效。例如 \u0026ldquo;xray.com\u0026rdquo; 匹配\u0026quot;xray.com\u0026quot; 但不匹配\u0026quot;www.xray.com\u0026quot;。 正则表达式：由 \u0026quot;regexp:\u0026quot; 开始，余下部分是一个正则表达式。当此正则表达式匹配目标域名时，该规则生效。例如 \u0026ldquo;regexp:\\\\.goo.*\\\\.com$\u0026rdquo; 匹配\u0026quot;www.google.com\u0026quot;或 \u0026ldquo;fonts.googleapis.com\u0026rdquo;，但不匹配 \u0026ldquo;google.com\u0026rdquo;。 子域名 (推荐)：由 \u0026quot;domain:\u0026quot; 开始，余下部分是一个域名。当此域名是目标域名或其子域名时，该规则生效。例如 \u0026ldquo;domain:xray.com\u0026rdquo; 匹配\u0026quot;www.xray.com\u0026quot;、\u0026ldquo;xray.com\u0026rdquo;，但不匹配\u0026quot;xray.com\u0026quot;。 子串：由 \u0026quot;keyword:\u0026quot; 开始，余下部分是一个字符串。当此字符串匹配目标域名中任意部分，该规则生效。比如 \u0026ldquo;keyword:sina.com\u0026rdquo; 可以匹配\u0026quot;sina.com\u0026quot;、\u0026ldquo;sina.com.cn\u0026rdquo; 和\u0026quot;www.sina.com\u0026quot;，但不匹配 \u0026ldquo;sina.cn\u0026rdquo;。 预定义域名列表：由 \u0026quot;geosite:\u0026quot; 开头，余下部分是一个名称，如 geosite:google 或者 geosite:cn。名称及域名列表参考 预定义域名列表。  servers: [string | ServerObject ]\n 一个 DNS 服务器列表，支持的类型有两种：DNS 地址（字符串形式）和 ServerObject 。\n当它的值是一个 DNS IP 地址时，如 \u0026quot;8.8.8.8\u0026quot;，Xray 会使用此地址的 53 端口进行 DNS 查询。\n当值为 \u0026quot;localhost\u0026quot; 时，表示使用本机预设的 DNS 配置。\n当值是 \u0026quot;https://host:port/dns-query\u0026quot; 的形式，如 \u0026quot;https://dns.google/dns-query\u0026quot;，Xray 会使用 DNS over HTTPS (RFC8484, 简称 DOH) 进行查询。有些服务商拥有 IP 别名的证书，可以直接写 IP 形式，比如 https://1.1.1.1/dns-query。也可使用非标准端口和路径，如 \u0026quot;https://a.b.c.d:8443/my-dns-query\u0026quot;\n当值是 \u0026quot;https+local://host:port/dns-query\u0026quot; 的形式，如 \u0026quot;https+local://dns.google/dns-query\u0026quot;，Xray 会使用 DOH本地模式 进行查询，即 DOH 请求不会经过 Routing/Outbound 等组件，直接对外请求，以降低耗时。一般适合在服务端使用。也可使用非标端口和路径。\nTIP 1\n当使用 localhost 时，本机的 DNS 请求不受 Xray 控制，需要额外的配置才可以使 DNS 请求由 Xray 转发。\n TIP 2\n不同规则初始化得到的 DNS 客户端会在 Xray 启动日志中以 info 级别体现，比如 local DOH、remote DOH 和 udp 等模式。\n clientIp: string\n 用于 DNS 查询时通知服务器以指定IP位置。不能是私有地址。\ntag: string\n 由内置 DNS 发出的查询流量，除 localhost 和 DOHL_ 模式外，都可以用此标识在路由使用 inboundTag 进行匹配。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;1.2.3.4\u0026#34;, \u0026#34;port\u0026#34;: 5353, \u0026#34;domains\u0026#34;: [ \u0026#34;domain:xray.com\u0026#34; ], \u0026#34;expectIPs\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ] }  address: address\n 一个 DNS 服务器列表，支持的类型有两种：DNS 地址（字符串形式）和 ServerObject 。\n当它的值是一个 DNS IP 地址时，如 \u0026ldquo;8.8.8.8\u0026rdquo;，Xray 会使用此地址的 53 端口进行 DNS 查询。\n当值为 \u0026ldquo;localhost\u0026rdquo; 时，表示使用本机预设的 DNS 配置。\n当值是 \u0026ldquo;https://host:port/dns-query\u0026rdquo; 的形式，如 \u0026ldquo;https://dns.google/dns-query\u0026quot;，Xray 会使用 DNS over HTTPS (RFC8484, 简称 DOH) 进行查询。有些服务商拥有 IP 别名的证书，可以直接写 IP 形式，比如 https://1.1.1.1/dns-query。也可使用非标准端口和路径，如 \u0026ldquo;https://a.b.c.d:8443/my-dns-query\u0026rdquo;\n当值是 \u0026ldquo;https+local://host:port/dns-query\u0026rdquo; 的形式，如 \u0026ldquo;https+local://dns.google/dns-query\u0026rdquo;，Xray 会使用 DOH本地模式 进行查询，即 DOH 请求不会经过 Routing/Outbound 等组件，直接对外请求，以降低耗时。一般适合在服务端使用。也可使用非标端口和路径。\n  port: number\n DNS 服务器端口，如 53。此项缺省时默认为 53。当使用 DOH 模式该项无效，非标端口应在 URL 中指定。\ndomains: [string]\n 一个域名列表，此列表包含的域名，将优先使用此服务器进行查询。域名格式和 路由配置 中相同。\nexpectIPs:[string]\n 一个 IP 范围列表，格式和 路由配置 中相同。\n当配置此项时，Xray DNS 会对返回的 IP 的进行校验，只返回包含 expectIPs 列表中的地址。\n如果未配置此项，会原样返回 IP 地址。\n"},{"uri":"https://badO1a5A90.github.io/guide/command/","title":"命令参数","tags":[],"description":"Project X 的文档.","content":" TIP\nXray 使用 go 风格的命令及参数\n 获取基本命令  您可以运行 xray help 来获得所有 xray 最基础的用法, 以及可用的命令及说明.\nXray is a platform for building proxies. Usage: xray \u0026lt;command\u0026gt; [arguments] The commands are: run Run Xray with config, the default command version Show current version of Xray api Call an API in an Xray process tls TLS tools uuid Generate new UUIDs Use \u0026#34;xray help \u0026lt;command\u0026gt;\u0026#34; for more information about a command. \nxray run  使用方法:\nxray run [-c config.json] [-confdir dir] Run Xray with config, the default command.\nThe -config=file, -c=file flags set the config files for Xray. Multiple assign is accepted.\nThe -confdir=dir flag sets a dir with multiple json config\nThe -format=json flag sets the format of config files. Default \u0026ldquo;json\u0026rdquo;.\nThe -test flag tells Xray to test config files only, without launching the server\n\nxray version  使用方法:\nxray version Version prints the build information for Xray executables.\n\nxray api  使用方法:\nxray api \u0026lt;command\u0026gt; [arguments] The commands are:\n restartlogger Restart the logger stats Get statistics statsquery Query statistics statssys Get system statistics adi Add inbounds ado Add outbounds rmi Remove inbounds rmo Remove outbounds  \nxray tls  使用方法:\nxray tls \u0026lt;command\u0026gt; [arguments] The commands are:\n cert Generate TLS certificates ping Ping the domain with TLS handshake  \nxray uuid  使用方法:\nxray uuid Generate new UUIDs.\n\n当-config没有指定时，Xray 将先后尝试从以下路径加载config.json:\n 工作目录（Working Directory） 环境变量中Xray.location.asset所指定的路径   "},{"uri":"https://badO1a5A90.github.io/develop/intro/guide/","title":"开发规范","tags":[],"description":"Project X 的文档.","content":"基本  版本控制  project X 的代码被托管在github上:\n xray 核心 xray-core xray-flutter xray-flutter 安装脚本 Xray-install 数据文件 Xray-rules-dat 配置模板 Xray-examples xray文档 XTLS.github.io  您可以使用 Git 来获取代码.\n 分支（Branch）  本项目的主干分支为 main, main 分支也是发布时所使用的代码分支, 因此需要确保 master 在任一时刻都是可编译可使用的。\n如果需要开发新的功能\n 请新开分支进行开发, 在开发完成并且经过充分测试后, 合并回主干分支. 新开分支如没有必要再存在时, 可以去除.   发布（Release）  In progress\n 建立尝鲜版本和稳定版本两个发布通道  临时版本, 主要用于特定情况的测试(比如从分支build的), 于TG群内/issue回复等渠道 发布特定版本 尝鲜版本可以为daily build , 用于尝鲜和获得即时反馈和再改进. 稳定版本为定时更新(比如周更), 合并稳定的修改并发布.     引用其它项目   Golang  产品代码建议使用 Golang 标准库和 golang.org/x/ 下的库； 如需引用其它项目，请事先创建 issue 讨论；   其它  不违反双方的协议，且对项目有帮助的工具，都可以使用。     开发流程  写代码之前  发现任何问题，或对项目有任何想法，请创建 Issue 讨论以减少重复劳动和消耗在代码上的时间。\n 修改代码   Golang  请参考 Effective Go； 每一次 push 之前，请运行：go fmt ./... 和 go fmt -s -l -e -w $(find . -type f -name \u0026quot;*.go\u0026quot; ! -name \u0026quot;*.pb.go\u0026quot;)； 每一次 push 之前，请确保测试通过：go test ./...； 提交 pull request 之前，请确保新增代码有超过 70% 的代码覆盖率（code coverage）；   其它  请注意代码的可读性。     Pull Request   提交 PR 之前，请先运行 git pull https://github.com/xray/xray-core.git 以确保 merge 可顺利进行； 一个 PR 只做一件事，如有对多个 bug 的修复，请对每一个 bug 提交一个 PR； 由于 Golang 的特殊需求（Package path），Go 项目的 PR 流程和其它项目有所不同 ,建议流程如下：  先 Fork 本项目，创建自己的 github.com/your/Xray-core 仓库； 克隆自己的 Xray 仓库到本地：git clone https://github.com/your/Xray-core.git； 基于 main 分支创建新的分支； 在自行创建的分支上作修改并提交修改(commit)； 在推送(push)修改完成的分支到自己的仓库前，先切换到 main 分支，运行 git pull https://github.com/v2fly/Xray-core.git 拉取最新的远端代码； 如果上一步拉取得到了新的远端代码，则切换到之前自己创建的分支，运行 git rebase master 执行分支合并操作。如遇到文件冲突，则需要解决冲突； 上一步处理完毕后，就可以把自己创建的分支推送到自己的仓库：git push -u origin your-branch 最后，把自己仓库的新推送的分支往 xtls/Xray-core 的 main 分支发 PR 即可； 请在 PR 的标题和正文中，完整表述此次 PR 解决的问题 / 新增的功能 / 代码所做的修改的用意等； 耐心等待开发者的回应。    对代码的修改  功能性问题  请提交至少一个测试用例（Test Case）来验证对现有功能的改动。\n性能相关  请提交必要的测试数据来证明现有代码的性能缺陷，或是新增代码的性能提升。\n新功能   如果新增功能对已有功能不影响，请提供可以开启/关闭的开关（如 flag），并使新功能保持默认关闭的状态； 大型新功能（比如增加一个新的协议）开发之前，请先提交一个 issue，讨论完毕之后再进行开发。  其它  视具体情况而定。\n Xray 编码规范  以下内容适用于 Xray 中的 Golang 代码。\n代码结构  Xray-core ├── app // 应用模块 │ ├── router // 路由 ├── common // 公用代码 ├── proxy // 通讯协议 │ ├── blackhole │ ├── dokodemo-door │ ├── freedom │ ├── socks │ ├── vmess ├── transport // 传输模块 编码规范  基本与 Golang 官方所推荐做法一致，有一些例外。写在这里以方便大家熟悉 Golang。\n命名   文件和目录名尽量使用单个英文单词，比如 hello.go；  如果实在没办法，则目录使用连接线／文件名使用下划线连接两个（或多个单词），比如 hello-world/hello_again.go； 测试代码使用 _test.go 结尾；   类型使用 Pascal 命名法，比如 ConnectionHandler；  对缩写不强制小写，即 HTML 不必写成 Html；   公开成员变量也使用 Pascal 命名法； 私有成员变量使用 小驼峰式命名法 ，如 privateAttribute ； 为了方便重构，方法建议全部使用 Pascal 命名法；  完全私有的类型放入 internal 。     内容组织   一个文件包含一个主要类型，及其相关的私有函数等； 测试相关的文件，如 Mock 等工具类，放入 testing 子目录。  "},{"uri":"https://badO1a5A90.github.io/qa/performance/","title":"性能相关的问题","tags":[],"description":"Project X 的文档.","content":" Q: 我是瓜瓜, 我想问 Xray 是不是最快的?是.\n Q: 什么工具或协议组合最快啊?/我应该用什么工具协议组合啊?个人自建上网,首先考虑安全性和伪装性,然后选择能满足自己需求的最高性能组合\n上网速率的高低, 体感的快慢, 根本的决定因素是线路 因此所有的选择跟你的实际环境息息相关,有时候需要一些特殊手段处理, 比如\n 比如低质量的线路可用使用CF加速. 比如晚上高峰期严重丢包的情况下, 可用使用mkcp(上限很低), 让线路尽量跑的更流畅一些.  在通常的环境下, 各种工具/协议组合的性能的高低, 可以参考Xray性能对比测试\n Q: mac和win 使用splice是不是无解了？ Windows 提供了 TransmitFile，但似乎不能用于两个 TCP 对接 Windows 10 有 WSL  WSL 1 使用 Splice 性能捉急. 不清楚 WSL 2 会不会带来额外拷贝开销，需要更多勇士尝试并反馈.   macOS暂无计划   Q: 有无xtls+splice+ws的计划？XTLS 原理上不支持 WS\n不带 TLS 的 WS 理论上可以支持类似 XTLS 的东西，目前没有实现它的计划\n或者 看看这里\n \n"},{"uri":"https://badO1a5A90.github.io/config/","title":"配置文件","tags":[],"description":"Project X 的文档.","content":" 这个章节将告诉您所有的 Xray 配置细节,掌握这些内容,在您手中 Xray 将发挥更大威力. 概述  Xray 的配置文件为 json 格式, 客户端和服务端的配置格式没有区别, 只是实际的配置内容不一样。\n形式如下:\n{ \u0026#34;log\u0026#34;: {}, \u0026#34;api\u0026#34;: {}, \u0026#34;dns\u0026#34;: {}, \u0026#34;routing\u0026#34;: {}, \u0026#34;policy\u0026#34;: {}, \u0026#34;inbounds\u0026#34;: [], \u0026#34;outbounds\u0026#34;: [], \u0026#34;transport\u0026#34;: {}, \u0026#34;stats\u0026#34;: {}, \u0026#34;reverse\u0026#34;: {} }  TIP\n如果你刚接触 Xray, 您可以先点击查看快速入门中的配置运行, 学习最基本的配置方式, 然后查看本章节内容以掌握所有 Xray 的配置方式.\n \n模块说明   log:LogObject\n 日志配置，控制 Xray输出日志的方式. api:ApiObject\n 提供了一些API接口供远程调用。 dns: DnsObject\n 内置的 DNS 服务器. 如果没有配置此项，则使用系统的 DNS 设置。 routing: RoutingObject\n 路由功能。可以设置规则分流数据从不同的outbound发出. policy: PolicyObject\n 本地策略，可以设置不同的用户等级和对应的策略设置。 inbounds: [ InboundObject ]\n 一个数组，每个元素是一个入站连接配置。 outbounds: [ OutboundObject ]\n 一个数组，每个元素是一个出站连接配置。 transport: TransportObject\n 用于配置 Xray 其它服务器建立和使用网络连接的方式。 stats: StatsObject\n 用于配置流量数据的统计。 reverse: ReverseObject\n 反向代理。可以把服务器端的流量向客户端转发，即逆向流量转发\n"},{"uri":"https://badO1a5A90.github.io/config/outbound-protocols/http/","title":"HTTP","tags":[],"description":"Project X 的文档.","content":"HTTP 协议。\nimportanthttp 协议没有对传输加密，不适宜经公网中传输，更容易成为被人用作攻击的肉鸡。\nhttp inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n TIP\nhttp proxy 只能代理 tcp 协议，udp 系的协议均不能通过。\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;192.168.108.1\u0026#34;, \u0026#34;port\u0026#34;: 3128, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ] } ] }  TIP\n目前 HTTP 协议 ounbound 中 streamSettings 设置 security 和 tlsSettings 是生效的。\n servers: [ ServerObject ]\n HTTP 服务器列表，其中每一项是一个服务器配置，若配置多个，循环使用 (RoundRobin)。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;192.168.108.1\u0026#34;, \u0026#34;port\u0026#34;: 3128, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ] }  address: string\n HTTP 代理服务器地址，必填。\nport: int\n HTTP 代理服务器端口，必填。\nuser: [AccountObject]\n 一个数组，数组中每个元素为一个用户帐号。默认值为空。\n\nAccountObject  { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\n"},{"uri":"https://badO1a5A90.github.io/config/transports/mkcp/","title":"mKCP","tags":[],"description":"Project X 的文档.","content":"mKCP 使用 UDP 来模拟 TCP 连接。\nmKCP 牺牲带宽来降低延迟。传输同样的内容，mKCP 一般比 TCP 消耗更多的流量。\nTIP\n请确定主机上的防火墙配置正确\n KcpObject  KcpObject 对应传输配置的 kcpSettings 项。\n{ \u0026#34;mtu\u0026#34;: 1350, \u0026#34;tti\u0026#34;: 20, \u0026#34;uplinkCapacity\u0026#34;: 5, \u0026#34;downlinkCapacity\u0026#34;: 20, \u0026#34;congestion\u0026#34;: false, \u0026#34;readBufferSize\u0026#34;: 1, \u0026#34;writeBufferSize\u0026#34;: 1, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }, \u0026#34;seed\u0026#34;: \u0026#34;Password\u0026#34; }  mtu: number\n 最大传输单元（maximum transmission unit）\n请选择一个介于 576 - 1460 之间的值。\n默认值为 1350。\ntti: number\n 传输时间间隔（transmission time interval），单位毫秒（ms），mKCP 将以这个时间频率发送数据。\n请选译一个介于 10 - 100 之间的值。\n默认值为 50。\nuplinkCapacity: number\n 上行链路容量，即主机发出数据所用的最大带宽，单位 MB/s，注意是 Byte 而非 bit。\n可以设置为 0，表示一个非常小的带宽。\n默认值 5。\ndownlinkCapacity: number\n 下行链路容量，即主机接收数据所用的最大带宽，单位 MB/s，注意是 Byte 而非 bit。\n可以设置为 0，表示一个非常小的带宽。\n默认值 20。\nTIP\nuplinkCapacity 和 downlinkCapacity 决定了 mKCP 的传输速度。\n以客户端发送数据为例，客户端的 uplinkCapacity 指定了发送数据的速度，而服务器端的 downlinkCapacity 指定了接收数据的速度。两者的值以较小的一个为准。\n推荐把 downlinkCapacity 设置为一个较大的值，比如 100，而 uplinkCapacity 设为实际的网络速度。当速度不够时，可以逐渐增加 uplinkCapacity 的值，直到带宽的两倍左右。\n congestion: true | false\n 是否启用拥塞控制。\n开启拥塞控制之后，Xray 会自动监测网络质量，当丢包严重时，会自动降低吞吐量；当网络畅通时，也会适当增加吞吐量。\n默认值为 false\nreadBufferSize: number\n 单个连接的读取缓冲区大小，单位是 MB。\n默认值为 2。\nwriteBufferSize: number\n 单个连接的写入缓冲区大小，单位是 MB。\n默认值为 2。\nTIP\nreadBufferSize 和 writeBufferSize 指定了单个连接所使用的内存大小。\n在需要高速传输时，指定较大的 readBufferSize 和 writeBufferSize 会在一定程度上提高速度，但也会使用更多的内存。\n在网速不超过 20MB/s 时，默认值 1MB 可以满足需求；超过之后，可以适当增加 readBufferSize 和 writeBufferSize 的值，然后手动平衡速度和内存的关系。\n header: HeaderObject\n 数据包头部伪装设置\nseed: string\n 可选的混淆密码，使用 AES-128-GCM 算法混淆流量数据，客户端和服务端需要保持一致。\n本混淆机制不能用于保证通信内容的安全，但可能可以对抗部分封锁。 TIP\n目前测试环境下开启此设置后没有出现原版未混淆版本的封端口现象\n \nHeaderObject  { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: string\n 伪装类型，可选的值有：\n \u0026quot;none\u0026quot;：默认值，不进行伪装，发送的数据是没有特征的数据包。 \u0026quot;srtp\u0026quot;：伪装成 SRTP 数据包，会被识别为视频通话数据（如 FaceTime）。 \u0026quot;utp\u0026quot;：伪装成 uTP 数据包，会被识别为 BT 下载数据。 \u0026quot;wechat-video\u0026quot;：伪装成微信视频通话的数据包。 \u0026quot;dtls\u0026quot;：伪装成 DTLS 1.2 数据包。 \u0026quot;wireguard\u0026quot;：伪装成 WireGuard 数据包。（并不是真正的 WireGuard 协议）  \n鸣谢   @skywind3000 发明并实现了 KCP 协议。 @xtaci 将 KCP 由 C 语言实现翻译成 Go。 @xiaokangwang 测试 KCP 与 Xray 的整合并提交了最初的 PR。  \n对 KCP 协议的改进  更小的协议头  原生 KCP 协议使用了 24 字节的固定头部，而 mKCP 修改为数据包 18 字节，确认（ACK）包 16 字节。更小的头部有助于躲避特征检查，并加快传输速度。\n另外，原生 KCP 的单个确认包只能确认一个数据包已收到，也就是说当 KCP 需要确认 100 个数据已收到时，它会发出 24 * 100 = 2400 字节的数据。其中包含了大量重复的头部数据，造成带宽的浪费。mKCP 会对多个确认包进行压缩，100 个确认包只需要 16 + 2 + 100 * 4 = 418 字节，相当于原生的六分之一。\n确认包重传  原生 KCP 协议的确认（ACK）包只发送一次，如果确认包丢失，则一定会导致数据重传，造成不必要的带宽浪费。而 mKCP 会以一定的频率重发确认包，直到发送方确认为止。单个确认包的大小为 22 字节，相比起数据包的 1000 字节以上，重传确认包的代价要小得多。\n连接状态控制  mKCP 可以有效地开启和关闭连接。当远程主机主动关闭连接时，连接会在两秒钟之内释放；当远程主机断线时，连接会在最多 30 秒内释放。\n原生 KCP 不支持这个场景。\n"},{"uri":"https://badO1a5A90.github.io/develop/protocols/mkcp/","title":"mKCP 协议","tags":[],"description":"Project X 的文档.","content":"mKCP 是流式传输协议，由 KCP 协议修改而来，可以按顺序传输任意的数据流。\n\n版本  mKCP 没有版本号，不保证版本之间兼容性。\n\n依赖  底层协议  mKCP 是一个基于 UDP 的协议，所有通讯使用 UDP 传输。\n\n函数   fnv: FNV-1a 哈希函数  输入参数为任意长度的字符串； 输入出一个 32 位无符号整数；    \n通讯过程   mKCP 将数据流拆成若干个数据包进行发送。一个数据流有一个唯一标识，用以区分不同的数据流。数据流中的每一个数据包都携带了同样的标识。 mKCP 没有握手过程，当收到一个数据包时，根据其携带的数据流的标识来判断是否为新的通话，或是正在进行中的通话。 每一个数据包中包含若干个片段（Segment），片段分为三类：数据（Data）、确认（ACK）、心跳（Ping）。每个片段需要单独处理。  \n数据格式  数据包     4 字节 2 字节 L 字节     认证信息 A 数据长度 L 片段部分    其中：\n 认证信息 A = fnv(片段部分），big endian； 片段部分可能包含多个片段；  \n数据片段     2 字节 1 字节 1 字节 4 字节 4 字节 4 字节 2 字节 Len 字节     标识 Conv 指令 Cmd 选项 Opt 时间戳 Ts 序列号 Sn 未确认序列号 Una 长度 Len 数据    其中：\n 标识 Conv: mKCP 数据流的标识 指令 Cmd: 常量 0x01 选项 Opt: 可选的值有：  0x00: 空选项 0x01: 对方已发出所有数据   时间戳 Ts: 当前片段从远端发送出来时的时间，big endian 序列号 Sn: 该数据片段时数据流中的位置，起始片段的序列号为 0，之后每个新片段按顺序加 1 未确认序列号 Una: 远端主机正在发送的，且尚未收到确认的最小的 Sn  \n确认片段     2 字节 1 字节 1 字节 4 字节 4 字节 4 字节 2 字节 Len * 4 字节     标识 Conv 指令 Cmd 选项 Opt 窗口 Wnd 下一接收序列号 Sn 时间戳 Ts 长度 Len 已收到的序列号    其中：\n 标识 Conv: mKCP 数据流的标识 指令 Cmd: 常量 0x00 选项 Opt: 同上 窗口 Wnd: 远端主机可以接收的最大序列号 下一接收序列号 Sn: 远端主机未收到的数据片段中的最小序列号 时间戳 Ts: 远端主机最新收到的数据片段的时间戳，可用于计算延迟 已收到的序列号: 每个 4 字节，表示此序列号的数据已经确认收到  注释：\n 远程主机期待收到序列号 [Sn, Wnd) 范围内的数据  \n心跳片段     2 字节 1 字节 1 字节 4 字节 4 字节 4 字节     标识 Conv 指令 Cmd 选项 Opt 未确认序列号 Una 下一接收序列号 Sn 延迟 Rto    其中：\n 标识 Conv: mKCP 数据流的标识 指令 Cmd: 可选的值有  0x02: 远端主机强行终止会话 0x03: 正常心跳   选项 Opt: 同上 未确认序列号 Una: 同数据片段的 Una 下一接收序列号 Sn: 同确认片段的 Sn 延迟 Rto: 远端主机自己计算出的延迟  "},{"uri":"https://badO1a5A90.github.io/config/inbound-protocols/socks/","title":"Socks","tags":[],"description":"Project X 的文档.","content":"标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。\nimportantsocks 协议没有对传输加密，不适宜经公网中传输\nsocks inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n InboundConfigurationObject { \u0026#34;auth\u0026#34;: \u0026#34;noauth\u0026#34;, \u0026#34;accounts\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ], \u0026#34;udp\u0026#34;: false, \u0026#34;ip\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;userLevel\u0026#34;: 0 }  auth: \u0026ldquo;noauth\u0026rdquo; | \u0026ldquo;password\u0026rdquo;\n Socks 协议的认证方式，支持 \u0026quot;noauth\u0026quot; 匿名方式和 \u0026quot;password\u0026quot; 用户密码方式。\n默认值为 \u0026quot;noauth\u0026quot;。\naccounts: [ AccountObject ]\n 一个数组，数组中每个元素为一个用户帐号。\n此选项仅当 auth 为 password 时有效。\n默认值为空。\nudp: true | false\n 是否开启 UDP 协议的支持。\n默认值为 false。\nip: address\n 当开启 UDP 时，Xray 需要知道本机的 IP 地址。\n默认值为 \u0026quot;127.0.0.1\u0026quot;。\nuserLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\nAccountObject  { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\n"},{"uri":"https://badO1a5A90.github.io/documents/level-1/work/","title":"Xray的工作模式","tags":[],"description":"Project X 的文档.","content":"单服务器模式  与其它的网络代理工具一样，你需要一台配置了 Xray 的服务器，然后在自己的设备上安装并配置 Xray 客户端，然后即可流畅地访问互联网。\nmermaid.initialize({startOnLoad:true}); graph LR; A(PC) -.- B(防火墙); B -.- C(墙外网站); A -- D(Xray/VPS); D -- C; A -- E(墙内网站);  一个 Xray 服务器可同时支持多台设备使用不同的代理协议访问。同时，经过合理的配置，Xray 可以识别并区分需要代理以及不需要代理的流量，直连的流量不需要绕路。\n\n桥接模式  如果你不想在每一台设备上都配置路由，你也可以设置一台中转服务器，用于接收客户端发来的所有流量，然后在服务器中进行转发判断。\nmermaid.initialize({startOnLoad:true}); graph LR; A(PC) -.- B(防火墙); B -.- C(墙外网站); A -- D(墙内 VPS); D -- E(墙外 VPS); E -- C; D -- F(墙内网站);  \n工作原理  在配置 Xray 之前，不妨先来看一下 Xray 的工作原理，以下是单个 Xray 进程的内部结构示意图。多个 Xray 之间相互独立，互不影响。\nmermaid.initialize({startOnLoad:true}); graph LR; A1(inbound) -- D(Dispatcher / Router / DNS); A2(inbound) -- D; A3(inbound) -- D; A4(inbound) -- D; D -- B1(outbound); D -- B2(outbound); D -- B3(outbound); D -- B4(outbound);   需要配置至少一个入站连接（Inbound）和一个出站连接（Outbound）才可以正常工作。  入站连接负责与客户端（如浏览器）通信：  入站连接通常可以配置用户认证，如 ID 和密码等； 入站连接收到数据之后，会交给分发器（Dispatcher）进行分发；   出站连接负责将数据发给服务器，如另一台主机上的 Xray。   当有多个出站连接时，可以配置路由（Routing）来指定某一类流量由某一个出站连接发出。  路由会在必要时查询 DNS 以获取更多信息来进行判断。    "},{"uri":"https://badO1a5A90.github.io/documents/","title":"使用心得","tags":[],"description":"Project X 的文档.","content":" 这个章节包含各种使用技巧,使用心得,大多来自于实际使用中的经验 小小白白话文 给予新手指导的使用心得\n请点击小小白白话文以进行查看\n 进阶文档 给予进阶用户指导的使用技巧\n点击进阶文档以进行查看\n  \n致谢非常感谢大家无私分享使用技巧和心得, 使得Xray日益强大.\n "},{"uri":"https://badO1a5A90.github.io/guide/document/","title":"使用文档","tags":[],"description":"Project X 的文档.","content":"查看文档   您可以使用左侧的菜单选择您要看的相关分类\n  选择某一项菜单之后, 可以在正文区顶部的导航栏快速切换此分类中的文章.\n   在查看文章时, 可以通过右边的标题列表, 快速切换到其中一个标题.\n   改进文档  Project X 的文档托管在github上.\n您可以通过以下步骤, 提交您对文档的改动:\n  从project X 文档仓库打开仓库, 点击右上角的 fork, fork 一份文档仓库的镜像到您自己的 github 仓库.\n  使用任何您喜欢的工具, 从您克隆的仓库获得文档的克隆, 如:\n    git clone https://github.com/yours/XTLS.github.io   基于 main 分支创建新的分支, 如:    git checkout -b your-branch    在新分支上做修改, 完成后提交修改\n  推送创建的分支到您的仓库\n    git push -u origin your-branch    打开 github, 点击 \u0026lsquo;Pull request\u0026rsquo; 向 project X 文档仓库发出PR.\n  请在 PR 的标题和正文中，概述此次 PR 新增/修改的内容等；\n  等待回应, 如果 PR 被 merge, 您做的修改将直接呈现在 Project X 文档网站。\n  "},{"uri":"https://badO1a5A90.github.io/documents/level-1/","title":"小小白白话文","tags":[],"description":"Project X 的文档.","content":" 这个章节是入门级的Xray使用心得分享, 如果您想掌握Xray的使用技巧, 可以从这里开始  小小白从入门到绝世高手 by @ 理性吃🍉\n 少年，我看你骨骼精奇，是万中无一的Xray奇才，维护世界和平就靠你了，我这有本秘籍\u0026mdash;\u0026gt;《小小白从入门到绝世高手》，见与你有缘，就十块卖给你了 In progress\n Xray的工作模式\n 本文介绍了 Xray 的两种基本工作模式和基本原理\n"},{"uri":"https://badO1a5A90.github.io/config/routing/","title":"路由","tags":[],"description":"Project X 的文档.","content":"路由功能模块可以将入站数据按不同规则由不同的出站连接发出，以达到按需代理的目的。\n如常见用法是分流国内外流量，Xray 可以通过内部机制判断不同地区的流量，然后将它们发送到不同的出站代理。\nRoutingObject  RoutingObject 对应配置文件的 routing 项。\n{ \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [], \u0026#34;balancers\u0026#34;: [] } }  domainStrategy: \u0026ldquo;AsIs\u0026rdquo; | \u0026ldquo;IPIfNonMatch\u0026rdquo; | \u0026ldquo;IPOnDemand\u0026rdquo;\n 域名解析策略，根据不同的设置使用不同的策略。\n \u0026quot;AsIs\u0026quot;：只使用域名进行路由选择。默认值。 \u0026quot;IPIfNonMatch\u0026quot;：当域名没有匹配任何规则时，将域名解析成 IP（A 记录或 AAAA 记录）再次进行匹配；  当一个域名有多个 A 记录时，会尝试匹配所有的 A 记录，直到其中一个与某个规则匹配为止； 解析后的 IP 仅在路由选择时起作用，转发的数据包中依然使用原始域名；   \u0026quot;IPOnDemand\u0026quot;：当匹配时碰到任何基于 IP 的规则，将域名立即解析为 IP 进行匹配；  rules: [RuleObject]\n 对应一个数组，数组中每个元素是一个规则。\n对于每一个连接，路由将根据这些规则依次进行判断，当一个规则生效时，即将这个连接转发至它所指定的 outboundTag或 balancerTag。\nTIP\n当没有匹配到任何规则时，流量默认由第一个outbound发出。\n balancers: [ BalancerObject ]\n 一个数组，数组中每个元素是一个负载均衡器的配置。\n当一个规则指向一个负载均衡器时，Xray 会通过此负载均衡器选出一个outbound, 然后由它转发流量。\n\nRuleObject  { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;baidu.com\u0026#34;, \u0026#34;qq.com\u0026#34;, \u0026#34;geosite:cn\u0026#34; ], \u0026#34;ip\u0026#34;: [ \u0026#34;0.0.0.0/8\u0026#34;, \u0026#34;10.0.0.0/8\u0026#34;, \u0026#34;fc00::/7\u0026#34;, \u0026#34;fe80::/10\u0026#34;, \u0026#34;geoip:cn\u0026#34; ], \u0026#34;port\u0026#34;: \u0026#34;53,443,1000-2000\u0026#34;, \u0026#34;sourcePort\u0026#34;: \u0026#34;53,443,1000-2000\u0026#34;, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;source\u0026#34;: [ \u0026#34;10.0.0.1\u0026#34; ], \u0026#34;user\u0026#34;: [ \u0026#34;love@xray.com\u0026#34; ], \u0026#34;inboundTag\u0026#34;: [ \u0026#34;tag-vmess\u0026#34; ], \u0026#34;protocol\u0026#34;: [ \u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;, \u0026#34;bittorrent\u0026#34; ], \u0026#34;attrs\u0026#34;: \u0026#34;attrs[\u0026#39;:method\u0026#39;] == \u0026#39;GET\u0026#39;\u0026#34;, \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;balancerTag\u0026#34;: \u0026#34;balancer\u0026#34; } \nimportant当多个属性同时指定时，这些属性需要 同时 满足，才可以使当前规则生效。\n type: \u0026ldquo;field\u0026rdquo;\n 目前只支持\u0026quot;field\u0026quot;这一个选项。\ndomain: [string]\n 一个数组，数组每一项是一个域名的匹配。有以下几种形式：\n 纯字符串：当此字符串匹配目标域名中任意部分，该规则生效。比如 \u0026ldquo;sina.com\u0026rdquo; 可以匹配 \u0026ldquo;sina.com\u0026rdquo;、\u0026ldquo;sina.com.cn\u0026rdquo; 和\u0026quot;www.sina.com\u0026quot;，但不匹配 \u0026ldquo;sina.cn\u0026rdquo;。 正则表达式：由 \u0026quot;regexp:\u0026quot; 开始，余下部分是一个正则表达式。当此正则表达式匹配目标域名时，该规则生效。例如 \u0026ldquo;regexp:\\\\.goo.*\\\\.com$\u0026rdquo; 匹配\u0026quot;www.google.com\u0026quot;或 \u0026ldquo;fonts.googleapis.com\u0026rdquo;，但不匹配 \u0026ldquo;google.com\u0026rdquo;。 子域名（推荐）：由 \u0026quot;domain:\u0026quot; 开始，余下部分是一个域名。当此域名是目标域名或其子域名时，该规则生效。例如 \u0026ldquo;domain:xray.com\u0026rdquo; 匹配\u0026quot;www.xray.com\u0026quot;、\u0026ldquo;xray.com\u0026rdquo;，但不匹配 \u0026ldquo;xray.com\u0026rdquo;。 完整匹配：由 \u0026quot;full:\u0026quot; 开始，余下部分是一个域名。当此域名完整匹配目标域名时，该规则生效。例如 \u0026ldquo;full:xray.com\u0026rdquo; 匹配 \u0026ldquo;xray.com\u0026rdquo; 但不匹配\u0026quot;www.xray.com\u0026quot;。 预定义域名列表：由 \u0026quot;geosite:\u0026quot; 开头，余下部分是一个名称，如 geosite:google 或者 geosite:cn。名称及域名列表参考 预定义域名列表。 从文件中加载域名：形如 \u0026quot;ext:file:tag\u0026quot;，必须以 ext:（小写）开头，后面跟文件名和标签，文件存放在 资源目录 中，文件格式与 geosite.dat 相同，标签必须在文件中存在。 TIP\n\u0026quot;ext:geoip.dat:cn\u0026quot; 等价于 \u0026quot;geoip:cn\u0026quot;\n   ip: [string]\n 一个数组，数组内每一个元素代表一个 IP 范围。当某一元素匹配目标 IP 时，此规则生效。有以下几种形式：\n IP：形如 \u0026quot;127.0.0.1\u0026quot;。 CIDR：形如 \u0026quot;10.0.0.0/8\u0026quot;。 预定义IP列表：此列表预置于每一个 Xray 的安装包中，文件名为 geoip.dat。使用方式形如 \u0026quot;geoip:cn\u0026quot;，必须以 geoip:（小写）开头，后面跟双字符国家代码，支持几乎所有可以上网的国家。  特殊值：\u0026quot;geoip:private\u0026quot;，包含所有私有地址，如 127.0.0.1。   从文件中加载 IP：形如 \u0026quot;ext:file:tag\u0026quot;，必须以 ext:（小写）开头，后面跟文件名和标签，文件存放在 资源目录 中，文件格式与 geoip.dat 相同标签必须在文件中存在。  port：number | string\n 目标端口范围，有三种形式：\n \u0026quot;a-b\u0026quot;：a 和 b 均为正整数，且小于 65536。这个范围是一个前后闭合区间，当目标端口落在此范围内时，此规则生效。 a：a 为正整数，且小于 65536。当目标端口为 a 时，此规则生效。 以上两种形式的混合，以逗号 \u0026ldquo;,\u0026rdquo; 分隔。形如：\u0026quot;53,443,1000-2000\u0026quot;。  sourcePort：number | string\n 来源端口，有三种形式：\n \u0026quot;a-b\u0026quot;：a 和 b 均为正整数，且小于 65536。这个范围是一个前后闭合区间，当目标端口落在此范围内时，此规则生效。 a：a 为正整数，且小于 65536。当目标端口为 a 时，此规则生效。 以上两种形式的混合，以逗号 \u0026ldquo;,\u0026rdquo; 分隔。形如：\u0026quot;53,443,1000-2000\u0026quot;。  network: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo; | \u0026ldquo;tcp,udp\u0026rdquo;\n 可选的值有 \u0026ldquo;tcp\u0026rdquo;、\u0026ldquo;udp\u0026rdquo; 或 \u0026ldquo;tcp,udp\u0026rdquo;，当连接方式是指定的方式时，此规则生效。\nsource: [string]\n 一个数组，数组内每一个元素是一个 IP 或 CIDR。当某一元素匹配来源 IP 时，此规则生效。\nuser: [string]\n 一个数组，数组内每一个元素是一个邮箱地址。当某一元素匹配来源用户时，此规则生效。\ninboundTag: [string]\n 一个数组，数组内每一个元素是一个标识。当某一元素匹配入站协议的标识时，此规则生效。\nprotocol: [ \u0026ldquo;http\u0026rdquo; | \u0026ldquo;tls\u0026rdquo; | \u0026ldquo;bittorrent\u0026rdquo; ]\n 一个数组，数组内每一个元素表示一种协议。当某一个协议匹配当前连接的协议类型时，此规则生效。 TIP\n必须开启入站代理中的 sniffing 选项, 才能嗅探出连接所使用的协议类型.\n attrs: string\n 一段脚本，用于检测流量的属性值。当此脚本返回真值时，此规则生效。\n脚本语言为 Starlark，它的语法是 Python 的子集。脚本接受一个全局变量 attrs，其中包含了流量相关的属性。\n目前只有 http 入站代理会设置这一属性。\n示例：\n 检测 HTTP GET：\u0026quot;attrs[':method'] == 'GET'\u0026quot; 检测 HTTP Path：\u0026quot;attrs[':path'].startswith('/test')\u0026quot; 检测 Content Type：\u0026quot;attrs['accept'].index('text/html') \u0026gt;= 0\u0026quot;  outboundTag: string\n 对应一个outbound的标识。\nbalancerTag: string\n 对应一个Balancer的标识。\nTIP\nbalancerTag 和 outboundTag 须二选一。当同时指定时，outboundTag 生效。\n \nBalancerObject  负载均衡器配置。当一个负载均衡器生效时，它会从指定的outbound中，按配置选出一个最合适的outbound，进行流量转发。\n{ \u0026#34;tag\u0026#34;: \u0026#34;balancer\u0026#34;, \u0026#34;selector\u0026#34;: [] }  tag: string\n 此负载均衡器的标识，用于匹配 RuleObject 中的 balancerTag。\nselector: [ string ]\n 一个字符串数组，其中每一个字符串将用于和outbound标识的前缀匹配。在以下几个outbound标识中：[ \u0026quot;a\u0026quot;, \u0026quot;ab\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;ba\u0026quot; ]，\u0026quot;selector\u0026quot;: [\u0026quot;a\u0026quot;] 将匹配到 [ \u0026quot;a\u0026quot;, \u0026quot;ab\u0026quot; ]。\n如果匹配到多个outbound，负载均衡器目前会从中随机选出一个作为最终的outbound。\n\n预定义域名列表  此列表预置于每一个 Xray 的安装包中，文件名为 geosite.dat。这个文件包含了一些常见的域名，使用方式：geosite:filename，如 geosite:google 表示对文件内符合 google 内包含的域名，进行路由筛选或 DNS 筛选。\n常见的域名有：\n category-ads：包含了常见的广告域名。 category-ads-all：包含了常见的广告域名，以及广告提供商的域名。 cn：相当于 geolocation-cn 和 tld-cn 的合集。 apple：包含了 Apple 旗下绝大部分域名。 google：包含了 Google 旗下绝大部分域名。 microsoft：包含了 Microsoft 旗下绝大部分域名。 facebook：包含了 Facebook 旗下绝大部分域名。 twitter：包含了 Twitter 旗下绝大部分域名。 telegram：包含了 Telegram 旗下绝大部分域名。 geolocation-cn：包含了常见的大陆站点域名。 geolocation-!cn：包含了常见的非大陆站点域名，同时包含了 tld-!cn。 tld-cn：包含了 CNNIC 管理的用于中国大陆的顶级域名，如以 .cn、.中国 结尾的域名。 tld-!cn：包含了非中国大陆使用的顶级域名，如以 .hk（香港）、.tw（台湾）、.jp（日本）、.sg（新加坡）、.us（美国）.ca（加拿大）等结尾的域名。  "},{"uri":"https://badO1a5A90.github.io/documents/level-2/","title":"进阶文档","tags":[],"description":"Project X 的文档.","content":" 这个章节包含进阶级的Xray使用心得分享, 如果您已经熟悉Xray, 那么这里的经验可以让您更加发挥Xray的威力 \n tproxy新版配置方案 by @kirin\n 这是里tproxy透明代理的一种新的iptbales配置方案 In progress\n"},{"uri":"https://badO1a5A90.github.io/qa/tproxy/","title":"透明代理相关问题","tags":[],"description":"Project X 的文档.","content":" Q: 我搭建了透明代理给我和我同宿舍/隔壁宿舍的同学用, 日志中出现很多 too many open files .怎么办? 急,在线等.让你的同学少用BT过代理下载American Video 在 /etc/systemd/system/xray.service 的 [Service] 下加 LimitNPROC=10000 和 LimitNOFILE=1000000.\n Q: sniffing的具体功能是什么，什么时候发挥作用?sniffing流量探测主要作用是用在透明代理等用途.\n他的一个典型工作流程是这样的.\n比如你有一个设备上网,去访问abc.com, 首先设备通过DNS查询得到abc.com的IP是1.2.3.4,然后设备会向1.2.3.4发起连接.\n 透明代理不设置嗅探的话,收到的连接请求是1.2.3.4,是不能走域名规则的路由分流的. 透明代理设置了sniffing,处理这个流量时,会从这个流量的数据中,嗅探出域名,abc.com. 然后把1.2.3.4重置为abc.com. 路由就可以根据域名进行符合域名规则的分流, 或者做更多的事情.  因为变成了一个向abc.com请求的连接,就可以做更多的事情,包括路由域名规则分流, 重新做DNS解析等等\u0026hellip;\n另一个sniffing的作用是可以嗅探BT流量的标识,把流量归类成BT类型. 然后可以在路由中根据BT类型来做规则,比如服务端用来拦截BT流量,比如客户端把BT流量固定发送到某个VPS去代理等.\n "},{"uri":"https://badO1a5A90.github.io/config/transports/h2/","title":"HTTP/2","tags":[],"description":"Project X 的文档.","content":"基于 HTTP/2 的传输方式。\n它完整按照 HTTP/2 标准实现，可以通过其它的 HTTP 服务器（如 Nginx）进行中转。\n由 HTTP/2 的建议，客户端和服务器必须同时开启 TLS 才可以正常使用这个传输方式。\nTIP\n当前版本的 HTTP/2 的传输方式并不强制要求服务器端有 TLS 配置.\n这使得可以在特殊用途的分流部署环境中，由外部网关组件完成 TLS 层对话，Xray 作为后端应用，网关和 Xray 间使用称为 h2c 的明文 http/2 进行通讯。\n HttpObject  HttpObject 对应传输配置的 httpSettings 项。\n{ \u0026#34;host\u0026#34;: [\u0026#34;xray.com\u0026#34;], \u0026#34;path\u0026#34;: \u0026#34;/random/path\u0026#34; }  host: [string]\n 一个字符串数组，每一个元素是一个域名。\n客户端会随机从列表中选出一个域名进行通信，服务器会验证域名是否在列表中。\npath string\n HTTP 路径，由 / 开头, 客户端和服务器必须一致。\n默认值为 \u0026quot;/\u0026quot;。\n"},{"uri":"https://badO1a5A90.github.io/config/inbound-protocols/","title":"inbound可用协议列表","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了目前所有可用于inbound的协议及具体配置细节. 协议列表   dokodemo-door\n Dokodemo door（任意门）可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。 http\n HTTP 协议 socks\n 标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。 vless\n VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 vmess\n VMess 是一个加密传输协议，，可以作为 Xray 客户端和服务器之间的桥梁。 trojan\n Trojan协议 shadowsocks\n Shadowsocks 协议。\n"},{"uri":"https://badO1a5A90.github.io/config/outbound-protocols/socks/","title":"Socks","tags":[],"description":"Project X 的文档.","content":"标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。\nimportantsocks 协议没有对传输加密，不适宜经公网中传输\nsocks inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }  servers: [ ServerObject ]\n Socks 服务器列表，其中每一项是一个服务器配置。\nServerObject { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  address: address\n 服务器地址, 必填\nTIP\n仅支持连接到 Socks 5 服务器。\n port: number\n 服务器端口, 必填\nusers: [ UserObject ]\n 一个数组表示的用户列表，数组中每个元素为一个用户配置。\n当列表不为空时，Socks 客户端会使用用户信息进行认证；如未指定，则不进行认证。\n默认值为空。\n\nUserObject  { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0\n"},{"uri":"https://badO1a5A90.github.io/config/inbound-protocols/vless/","title":"VLESS","tags":[],"description":"Project X 的文档.","content":" important目前 VLESS 没有自带加密，请用于可靠信道，如 TLS。 目前 VLESS 不支持分享。\n VLESS 是一个无状态的轻量传输协议，它分为入站和出站两部分，可以作为 Xray 客户端和服务器之间的桥梁。\n与 VMess 不同，VLESS 不依赖于系统时间，认证方式同样为 UUID，但不需要 alterId。\nInboundConfigurationObject { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34; } ], \u0026#34;decryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 } ] }  clients: [ ClientObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户ClientObject。\n decryption: \u0026ldquo;none\u0026rdquo;\n 现阶段需要填 \u0026quot;none\u0026quot;，不能留空。 若未正确设置 decryption 的值，使用 Xray 或 -test 时会收到错误信息。\n注意这里是 decryption，和 clients 同级。 decryption 和 vmess 协议的 encryption 的位置不同，是因为若套一层约定加密，服务端需要先解密才能知道是哪个用户。\nfallbacks: [ FallbackObject ]\n 一个数组，包含一系列强大的回落分流配置（可选）。\n ClientObject  { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34; }  id: string\n VLESS 的用户 ID，必须是一个合法的 UUID，你也可以用 UUID 生成它。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nemail: string\n 用户邮箱，用于区分不同用户的流量（日志、统计）。\n 配置模板  Xray-examples 有完整的 VLESS 配置示例供参考。（但目前不能保证其它协议的配置示例质量）\n 客户端开发指引   VLESS 协议本身还会有不兼容升级，但客户端配置文件参数基本上是只增不减的。所以如果你开发了用 core 的客户端，现在就可以适配。 iOS 客户端的协议实现则需紧跟升级。 视觉标准：UI 标识请统一用 VLESS，而不是 VLess / Vless / vless，配置文件不受影响，代码内则顺其自然。 encryption 应做成输入框而不是选择框，新配置的默认值应为 none，若用户置空则应代填 none。  以下为已支持图形化配置 VLESS 的部分客户端列表，推荐使用：（按实现时间先后顺序排列）\n 新型协议回落模式解析  In progress\n VLESS 分享链接标准  In progress\n"},{"uri":"https://badO1a5A90.github.io/qa/fallback/","title":"回落相关问题","tags":[],"description":"Project X 的文档.","content":" Q: 回落是个啥?好吃吗?Fallback 是 Xray 的最强大功能之一, 可有效防止主动探测, 自由配置常用端口多服务共享\n点此查看详情 回落\n Q: 为什么我回落以后nginx日志的IP是 127.0.0.1?需要开启 proxy protocal\n Q: 我还是上一题的提问者, 那么我如何使用gproxy protocal,达到所有日志都有源IP的目的呢?等待好心人写一篇小小白白话文\n "},{"uri":"https://badO1a5A90.github.io/develop/","title":"开发指南","tags":[],"description":"Project X 的文档.","content":"In progress\n"},{"uri":"https://badO1a5A90.github.io/config/policy/","title":"本地策略","tags":[],"description":"Project X 的文档.","content":"本地策略，可以设置不同的用户等级和对应的策略设置，比如连接超时设置。Xray 处理的每一个连接都对应一个用户，按照用户的等级（level）应用不同的策略。\nPolicyObject  PolicyObject 对应配置文件的 policy 项。\n{ \u0026#34;policy\u0026#34;: { \u0026#34;levels\u0026#34;: { \u0026#34;0\u0026#34;: { \u0026#34;handshake\u0026#34;: 4, \u0026#34;connIdle\u0026#34;: 300, \u0026#34;uplinkOnly\u0026#34;: 2, \u0026#34;downlinkOnly\u0026#34;: 5, \u0026#34;statsUserUplink\u0026#34;: false, \u0026#34;statsUserDownlink\u0026#34;: false, \u0026#34;bufferSize\u0026#34;: 4 } }, \u0026#34;system\u0026#34;: { \u0026#34;statsInboundUplink\u0026#34;: false, \u0026#34;statsInboundDownlink\u0026#34;: false, \u0026#34;statsOutboundUplink\u0026#34;: false, \u0026#34;statsOutboundDownlink\u0026#34;: false } } }  level: map{string: LevelPolicyObject}\n 一组键值对，每个键是一个字符串形式的数字（JSON 的要求），比如 \u0026quot;0\u0026quot;、\u0026quot;1\u0026quot; 等，双引号不能省略，此数字对应用户等级。每一个值是一个 LevelPolicyObject.\nTIP\n每个入站出站代理现在都可以设置用户等级，Xray 会根据实际的用户等级应用不同的本地策略。\n system: SystemPolicyObject\n Xray系统级别的策略\n\nLevelPolicyObject  { \u0026#34;handshake\u0026#34;: 4, \u0026#34;connIdle\u0026#34;: 300, \u0026#34;uplinkOnly\u0026#34;: 2, \u0026#34;downlinkOnly\u0026#34;: 5, \u0026#34;statsUserUplink\u0026#34;: false, \u0026#34;statsUserDownlink\u0026#34;: false, \u0026#34;bufferSize\u0026#34;: 10240 }  handshake: number\n 连接建立时的握手时间限制。单位为秒。默认值为 4。在入站代理处理一个新连接时，在握手阶段如果使用的时间超过这个时间，则中断该连接。\nconnIdle: number\n 连接空闲的时间限制。单位为秒。默认值为 300。inbound/outbound处理一个连接时，如果在 connIdle 时间内，没有任何数据被传输（包括上行和下行数据），则中断该连接。\nuplinkOnly: number\n 当连接下行线路关闭后的时间限制。单位为秒。默认值为 2。当服务器（如远端网站）关闭下行连接时，出站代理会在等待 uplinkOnly 时间后中断连接。\ndownlinkOnly: number\n 当连接上行线路关闭后的时间限制。单位为秒。默认值为 5。当客户端（如浏览器）关闭上行连接时，入站代理会在等待 downlinkOnly 时间后中断连接。\nTIP\n在 HTTP 浏览的场景中，可以将 uplinkOnly 和 downlinkOnly 设为 0，以提高连接关闭的效率。\n statsUserUplink: true | false\n 当值为 true 时，开启当前等级的所有用户的上行流量统计。\nstatsUserDownlink: true | false\n 当值为 true 时，开启当前等级的所有用户的下行流量统计。\nbufferSize: number\n 每个连接的内部缓存大小。单位为 kB。当值为 0 时，内部缓存被禁用。\n默认值:\n 在 ARM、MIPS、MIPSLE 平台上，默认值为 0。 在 ARM64、MIPS64、MIPS64LE 平台上，默认值为 4。 在其它平台上，默认值为 512。  TIP\nbufferSize 选项会覆盖 环境变量中 Xray.ray.buffer.size 的设定。\n \nSystemPolicyObject  { \u0026#34;statsInboundUplink\u0026#34;: false, \u0026#34;statsInboundDownlink\u0026#34;: false, \u0026#34;statsOutboundUplink\u0026#34;: false, \u0026#34;statsOutboundDownlink\u0026#34;: false }  statsInboundUplink: true | false\n 当值为 true 时，开启所有入站代理的上行流量统计。 statsInboundDownlink: true | false\n 当值为 true 时，开启所有入站代理的下行流量统计。 statsOutboundUplink: true | false\n 当值为 true 时，开启所有出站代理的上行流量统计。 statsOutboundDownlink: true | false\n 当值为 true 时，开启所有出站代理的下行流量统计。\n"},{"uri":"https://badO1a5A90.github.io/config/inbounds/","title":"Inbounds","tags":[],"description":"Project X 的文档.","content":"入站连接用于接收发来的数据，可用的协议请见inbound 可用协议列表。\nInboundObject  InboundObject 对应配置文件中 inbounds 项的一个子元素。\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1080, \u0026#34;protocol\u0026#34;: \u0026#34;协议名称\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;streamSettings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;标识\u0026#34;, \u0026#34;sniffing\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;destOverride\u0026#34;: [\u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;] }, \u0026#34;allocate\u0026#34;: { \u0026#34;strategy\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;refresh\u0026#34;: 5, \u0026#34;concurrency\u0026#34;: 3 } } ] }  listen: address\n 监听地址，IP 地址或 Unix domain socket，默认值为 \u0026quot;0.0.0.0\u0026quot;，表示接收所有网卡上的连接.\n可以指定一个系统可用的 IP 地址。\n支持填写 Unix domain socket，格式为绝对路径，形如 \u0026quot;/dev/shm/domain.socket\u0026quot;，可在开头加 \u0026quot;@\u0026quot; 代表 abstract，\u0026quot;@@\u0026quot; 则代表带 padding 的 abstract。\n填写 Unix domain socket 时，port 和 allocate 将被忽略，协议目前可选 VLESS、VMess、Trojan，传输方式可选 TCP、WebSocket、HTTP/2。\nport: number | \u0026ldquo;env:variable\u0026rdquo; | string\n 端口。接受的格式如下:\n 整型数值：实际的端口号。 环境变量：以 \u0026quot;env:\u0026quot; 开头，后面是一个环境变量的名称，如 \u0026quot;env:PORT\u0026quot;。Xray 会以字符串形式解析这个环境变量。 字符串：可以是一个数值类型的字符串，如 \u0026quot;1234\u0026quot;；或者一个数值范围，如 \u0026quot;5-10\u0026quot; 表示端口 5 到端口 10，这 6 个端口。  当只有一个端口时，Xray 会在此端口监听入站连接。当指定了一个端口范围时，取决于 allocate 设置。\nprotocol: string\n 连接协议名称，可选的协议类型见inbound 可用协议列表。\nsettings: InboundConfigurationObject\n 具体的配置内容，视协议不同而不同。详见每个协议中的 InboundConfigurationObject。\nstreamSettings: StreamSettingsObject\n 底层传输方式（transport）是当前 Xray 节点和其它节点对接的方式\n tag: string\n 此入站连接的标识，用于在其它的配置中定位此连接。\nimportant当其不为空时，其值必须在所有 tag 中 唯一。\n sniffing: SniffingObject\n 流量探测主要作用于在透明代理等用途. 比如一个典型流程如下:\n 如有一个设备上网,去访问abc.com,首先设备通过DNS查询得到abc.com的IP是1.2.3.4,然后设备会向1.2.3.4去发起连接. 如果不设置嗅探,Xray收到的连接请求是1.2.3.4,并不能用于域名规则的路由分流. 当设置了sniffing中的enable为true,Xray处理此连接的流量时,会从流量的数据中,嗅探出域名,即abc.com Xray会把1.2.3.4重置为abc.com.路由就可以根据域名去进行路由的域名规则的分流  因为变成了一个向abc.com请求的连接, 就可以做更多的事情, 除了路由域名规则分流, 还能重新做DNS解析等其他工作.\n当设置了sniffing中的enable为true, 还能嗅探出bittorrent类型的流量, 然后可以在路由中配置\u0026quot;protocol\u0026quot;项来设置规则处理BT流量, 比如服务端用来拦截BT流量, 或客户端固定转发BT流量到某个VPS去等.\nallocate: AllocateObject\n 当设置了多个port时, 端口分配的具体设置\n\nSniffingObject  { \u0026#34;enabled\u0026#34;: true, \u0026#34;destOverride\u0026#34;: [\u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;] }  enabled: true | false\n 是否开启流量探测。 destOverride: [\u0026ldquo;http\u0026rdquo; | \u0026ldquo;tls\u0026rdquo;]\n 当流量为指定类型时，按其中包括的目标地址重置当前连接的目标。\n\nAllocateObject  { \u0026#34;strategy\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;refresh\u0026#34;: 5, \u0026#34;concurrency\u0026#34;: 3 }  strategy: \u0026ldquo;always\u0026rdquo; | \u0026ldquo;random\u0026rdquo;\n 端口分配策略。\n \u0026quot;always\u0026quot; 表示总是分配所有已指定的端口，port 中指定了多少个端口，Xray 就会监听这些端口。 \u0026quot;random\u0026quot; 表示随机开放端口，每隔 refresh 分钟在 port 范围中随机选取 concurrency 个端口来监听。  refresh: number\n 随机端口刷新间隔，单位为分钟。最小值为 2，建议值为 5。这个属性仅当 strategy 设置为 \u0026quot;random\u0026quot; 时有效。 concurrency: number\n 随机端口数量。最小值为 1，最大值为 port 范围的三分之一。建议值为 3。\n"},{"uri":"https://badO1a5A90.github.io/config/outbound-protocols/","title":"ounbound可用协议列表","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了目前所有可用于outbound的协议及具体配置细节. 协议列表   blackhole\n Blackhole（黑洞）是一个出站数据协议，它会阻碍所有数据的出站，配合 路由（Routing） 一起使用，可以达到禁止访问某些网站的效果。 dns\n DNS 是一个出站协议，主要用于拦截和转发 DNS 查询。此出站协议只能接收 DNS 流量（包含基于 UDP 和 TCP 协议的查询），其它类型的流量会导致错误。 freedom\n Freedom 是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。 http\n HTTP 协议 socks\n 标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。 vless\n VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 vmess\n VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 trojan\n Trojan协议 shadowsocks\n Shadowsocks 协议。\n"},{"uri":"https://badO1a5A90.github.io/config/transports/quic/","title":"QUIC","tags":[],"description":"Project X 的文档.","content":"QUIC 全称 Quick UDP Internet Connection，是由 Google 提出的使用 UDP 进行多路并发传输的协议。其主要优势是:\n 减少了握手的延迟（1-RTT 或 0-RTT） 多路复用，并且没有 TCP 的阻塞问题 连接迁移，（主要是在客户端）当由 Wifi 转移到 4G 时，连接不会被断开。  QUIC 目前处于实验期，使用了正在标准化过程中的 IETF 实现，不能保证与最终版本的兼容性。\n 默认设定:  12 字节的 Connection ID 30 秒没有数据通过时自动断开连接 (可能会影响一些长连接的使用)    QuicObject  QuicObject 对应传输配置的 quicSettings 项。\nimportant对接的两端的配置必须完全一致，否则连接失败。 QUIC 强制要求开启 TLS，在传输配置中没有开启 TLS 时，Xray 会自行签发一个证书进行 TLS 通讯。\n { \u0026#34;security\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; } }  security: \u0026ldquo;none\u0026rdquo; | \u0026ldquo;aes-128-gcm\u0026rdquo; | \u0026ldquo;chacha20-poly1305\u0026rdquo;\n 加密方式。\n此加密是对 QUIC 数据包的加密，加密后数据包无法被探测。\n默认值为不加密。\nkey: string\n 加密时所用的密钥。\n可以是任意字符串。当 security 不为 \u0026quot;none\u0026quot; 时有效。\nheader: HeaderObject\n 数据包头部伪装设置\n\nHeaderObject  { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: string\n 伪装类型，可选的值有：\n \u0026quot;none\u0026quot;：默认值，不进行伪装，发送的数据是没有特征的数据包。 \u0026quot;srtp\u0026quot;：伪装成 SRTP 数据包，会被识别为视频通话数据（如 FaceTime）。 \u0026quot;utp\u0026quot;：伪装成 uTP 数据包，会被识别为 BT 下载数据。 \u0026quot;wechat-video\u0026quot;：伪装成微信视频通话的数据包。 \u0026quot;dtls\u0026quot;：伪装成 DTLS 1.2 数据包。 \u0026quot;wireguard\u0026quot;：伪装成 WireGuard 数据包。（并不是真正的 WireGuard 协议）  TIP\n当加密和伪装都不启用时，数据包即为原始的 QUIC 数据包，可以与其它的 QUIC 工具对接。\n为了避免被探测，建议加密或伪装至少开启一项。\n "},{"uri":"https://badO1a5A90.github.io/config/outbound-protocols/vless/","title":"VLESS","tags":[],"description":"Project X 的文档.","content":" important目前 VLESS 没有自带加密，请用于可靠信道，如 TLS。 目前 VLESS 不支持分享。\n VLESS 是一个无状态的轻量传输协议，它分为入站和出站两部分，可以作为 Xray 客户端和服务器之间的桥梁。\n与 VMess 不同，VLESS 不依赖于系统时间，认证方式同样为 UUID，但不需要 alterId。\nOutboundConfigurationObject  { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }  vnext: [ ServerObject ]\n 一个数组, 表示 VLESS 服务器列表，包含一组指向服务端的配置, 其中每一项是一个服务器配置。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  address: address\n 服务端地址，指向服务端，支持域名、IPv4、IPv6。\nport: number\n 服务端端口，通常与服务端监听的端口相同。\nusers: [ UserObject ]\n 数组, 一组服务端认可的用户列表, 其中每一项是一个用户配置\n\nUserObject  { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 }  id: string\n VLESS 的用户 ID，必须是一个合法的 UUID，你可以用 在线工具 生成它。\nencryption: \u0026ldquo;none\u0026rdquo;\n 需要填 \u0026quot;none\u0026quot;，不能留空。\n该要求是为了提醒使用者没有加密，也为了以后出加密方式时，防止使用者填错属性名或填错位置导致裸奔。 若未正确设置 encryption 的值，使用 Xray 或 -test 时会收到错误信息。\nflow: string\n VLESS 的流控模式.\n目前 VLESS 有以下流控模式可选:\n \u0026ldquo;xtls-rprx-origin\u0026rdquo; : 最初的流控方式 \u0026ldquo;xtls-rprx-origin-udp443\u0026rdquo; : 同xtls-rprx-origin, 但是放行了目标为443端口的UDP流量. \u0026ldquo;xtls-rprx-direct\u0026rdquo; : 所有平台皆可使用的典型流控方式 \u0026ldquo;xtls-rprx-direct-udp443\u0026rdquo; : 同xtls-rprx-direct, 但是放行了目标为443端口的UDP流量. \u0026ldquo;xtls-rprx-splice\u0026rdquo; : Linux 平台下最建议使用的流控方式 \u0026ldquo;xtls-rprx-splice-udp443\u0026rdquo; : 同xtls-rprx-splice, 但是放行了目标为443端口的UDP流量.  如果填写了流控模式, 还需将 outbound 的 security 设置成 \u0026ldquo;xtls\u0026rdquo;, 将 \u0026ldquo;tlsSettings\u0026rdquo; 改成 \u0026ldquo;xtlsSettings\u0026rdquo;. 可参考streamSettings设置\nimportantSplice 是 Linux Kernel 提供的函数，系统内核直接转发 TCP，不再经过 Xray 的内存，大大减少了数据拷贝、CPU 上下文切换的次数。\nsplice 模式的的使用限制:\n Linux 环境 inbound为 任意门、Socks、HTTP 等纯净的 TCP 连接, 或 XTLS 模式的inbound outbound 为 VLESS XTLS 或 Trojan XTLS   level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\n配置模板  Xray-examples 有完整的 VLESS 配置示例供参考。（但目前不能保证其它协议的配置示例质量）\n 客户端开发指引   VLESS 协议本身还会有不兼容升级，但客户端配置文件参数基本上是只增不减的。所以如果你开发了用 core 的客户端，现在就可以适配。 iOS 客户端的协议实现则需紧跟升级。 视觉标准：UI 标识请统一用 VLESS，而不是 VLess / Vless / vless，配置文件不受影响，代码内则顺其自然。 encryption 应做成输入框而不是选择框，新配置的默认值应为 none，若用户置空则应代填 none。  以下为已支持图形化配置 VLESS 的部分客户端列表，推荐使用：（按实现时间先后顺序排列）\n 新型协议回落模式解析  In progress\n VLESS 分享链接标准  In progress\n"},{"uri":"https://badO1a5A90.github.io/config/inbound-protocols/vmess/","title":"vmess","tags":[],"description":"Project X 的文档.","content":"VMess 是一个加密传输协议，通常作为 Xray 客户端和服务器之间的桥梁。\nimportantVMess 依赖于系统时间，请确保使用 Xray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。\n InboundConfigurationObject  { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34; } ], \u0026#34;default\u0026#34;: { \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 0 }, \u0026#34;detour\u0026#34;: { \u0026#34;to\u0026#34;: \u0026#34;tag_to_detour\u0026#34; }, \u0026#34;disableInsecureEncryption\u0026#34;: false }  clients: [ ClientObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户ClientObject。\n当此配置用作动态端口时，Xray 会自动创建用户。\ndetour: DetourObject\n 指示对应的出站协议使用另一个服务器。\ndefault: DefaultObject\n 可选，clients 的默认配置。仅在配合detour时有效。\ndisableInsecureEncryption: true | false\n 是否禁止客户端使用不安全的加密方式，如果设置为 true 当客户端指定下列加密方式时，服务器会主动断开连接。\n \u0026quot;none\u0026quot; \u0026quot;aes-128-cfb\u0026quot;  默认值为false。\n\nClientObject  { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 4, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34; }  id: string\n VMess 的用户 ID。必须是一个合法的 UUID。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nalterId: number\n 为了进一步防止被探测，一个用户可以在主 ID 的基础上，再额外生成多个 ID。这里只需要指定额外的 ID 的数量，推荐值为 0 代表启用 VMessAEAD。\n最大值 65535。这个值不能超过服务器端所指定的值。\n不指定的话，默认值是 0。\nTIP\n客户端 AlterID 设置为 0 代表启用 VMessAEAD ；服务端为自动适配，可同时兼容启用和未开启 VMessAEAD 的客户端。\n客户端可通过设置环境变量 Xray_VMESS_AEAD_DISABLED=true 强行禁用 VMessAEAD\n email: string\n 用户邮箱地址，用于区分不同用户的流量。\n\nDetourObject  { \u0026#34;to\u0026#34;: \u0026#34;tag_to_detour\u0026#34; }  to: string\n 一个 inbound 的tag, 指定的 inbound 的必须是使用 VMess 协议的 inbound.\n\nDefaultObject  { \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 0 }  level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nalterId: number\n 动态端口的默认alterId，默认值为0。\n\nVMess MD5 认证信息 玷污机制  为了进一步对抗可能的探测和封锁，每个 VMess 认证数据的服务端结构都会包含一个一次写入的玷污状态标记，初始状态为无瑕状态，当服务器检测到重放探测时或者因为其他原因入站连接出错以致校验数据不正确时，该连接所对应的请求认证数据会被玷污。\n被玷污的认证数据无法被用于建立连接，当攻击者或客户端使用被玷污的认证数据建立连接时，服务器会输出包含 \u0026ldquo;invalid user\u0026rdquo; \u0026ldquo;ErrTainted\u0026rdquo; 的错误信息，并阻止该连接。\n当服务器没有受到重放攻击时，该机制对正常连接的客户端没有影响。\n如果服务器正在被重放攻击，可能会出现连接不稳定的情况。\nTIP\n拥有服务器 UUID 以及其他连接数据的恶意程序可能根据此机制对服务器发起拒绝服务攻击，受到此类攻击的服务可以通过修改 proxy/vmess/validator.go 文件中 func (v *TimedUserValidator) BurnTaintFuse(userHash []byte) error 函数的 atomic.CompareAndSwapUint32(pair.taintedFuse, 0, 1) 语句为 atomic.CompareAndSwapUint32(pair.taintedFuse, 0, 0) 来解除服务器对此类攻击的安全保护机制。使用 VMessAEAD 认证机制的客户端不受到 VMess MD5 认证信息 玷污机制 的影响。\n "},{"uri":"https://badO1a5A90.github.io/qa/xtls/","title":"XTLS相关问题","tags":[],"description":"Project X 的文档.","content":" Q: XTLS是个啥?好吃吗?XTLS 是 Xray 的原创黑科技, 也是使 Xray 性能一骑绝尘的核心动力\n点此查看详情 XTLS\n Q: TLS和XTLS有啥区别?XTLS会不安全吗?安全性没有区别.\n性能有区别.XTLS比TLS快的多的多的多.\n "},{"uri":"https://badO1a5A90.github.io/qa/","title":"常见问答","tags":[],"description":"Project X 的文档.","content":" 如果您有任何疑问, 不妨先到这里看看是不是有人遇到了同样的问题, 并且已经解决了. 下载和安装中的问题 首先您可以点击查看下载和安装Xray\n如果碰到问题, 可以点击这里下载和安装中的问题\n 配置和运行时的问题 首先您可以点击查看配置和运行Xray\n如果碰到问题, 可以点击这里配置和运行时的问题\n 性能相关的问题 速率, 延迟, CPU占用, 内存占用\u0026hellip;\n这些相关的问题请点击这里性能相关的问题\n 透明代理的问题 如果您使用了透明代理\n遇到问题不妨点击这里透明代理的问题\n  \n回落相关的问题 回落是Xray最强大功能之一, 灵活且强大, 可以玩很多杂技\n如有相关问题可以点击回落相关的问题\n XTLS相关的问题 XTLS 是 Xray独创的新科技, 因此 Xray 的性能一骑绝尘.\n如有相关问题可以点击XTLS相关的问题\n  关于 Xray Xray 的非技术问题\n点击查看Xray 的非技术问题\n  \n如果在这里找不到你要的答案或者觉得答案不够细致, 不妨再去翻一翻大案牍术\n "},{"uri":"https://badO1a5A90.github.io/config/outbounds/","title":"Outbounds","tags":[],"description":"Project X 的文档.","content":"出站连接用于发送数据，可用的协议请见outbound 可用协议列表。\nOutboundObject  OutboundObject 对应配置文件中 outbounds 项的一个子元素。 TIP\n列表中的第一个元素作为主outbound。当路由匹配不存在或没有匹配成功时，流量由主outbound发出。\n { \u0026#34;outbounds\u0026#34;: [ { \u0026#34;sendThrough\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;协议名称\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;标识\u0026#34;, \u0026#34;streamSettings\u0026#34;: {}, \u0026#34;proxySettings\u0026#34;: { \u0026#34;tag\u0026#34;: \u0026#34;another-outbound-tag\u0026#34; }, \u0026#34;mux\u0026#34;: {} } ] }  sendThrough: address\n 用于发送数据的 IP 地址，当主机有多个 IP 地址时有效，默认值为 \u0026quot;0.0.0.0\u0026quot;。 protocol: string\n 连接协议名称，可选的协议类型见outbound 可用协议列表。 settings: OutboundConfigurationObject\n 具体的配置内容，视协议不同而不同。详见每个协议中的 OutboundConfigurationObject。 tag: string\n 此出站连接的标识，用于在其它的配置中定位此连接。\nimportant当其不为空时，其值必须在所有 tag 中 唯一。\n streamSettings: StreamSettingsObject\n 底层传输方式（transport）是当前 Xray 节点和其它节点对接的方式\nproxySettings: ProxySettingsObject\n 出站代理配置。当出站代理生效时，此outbound的 streamSettings 将不起作用。\nmux: MuxObject\n Mux 相关的具体配置。\n\nProxySettingsObject  { \u0026#34;tag\u0026#34;: \u0026#34;another-outbound-tag\u0026#34; }  tag: string\n 当指定另一个outbound的标识时，此outbound发出的数据，将被转发至所指定的outbound发出。\n\nMuxObject  Mux 功能是在一条 TCP 连接上分发多个 TCP 连接的数据。实现细节详见 Mux.Cool。Mux 是为了减少 TCP 的握手延迟而设计，而非提高连接的吞吐量。使用 Mux 看视频、下载或者测速通常都有反效果。Mux 只需要在客户端启用，服务器端自动适配。\nMuxObject 对应 OutboundObject 中的 mux 项。\n{ \u0026#34;enabled\u0026#34;: false, \u0026#34;concurrency\u0026#34;: 8 }  enabled: true | false\n 是否启用 Mux 转发请求，默认值 false。 concurrency: number\n 最大并发连接数。最小值 1，最大值 1024，默认值 8。\n这个数值表示了一个 TCP 连接上最多承载的 Mux 连接数量。比如设置 concurrency=8 时，当客户端发出了 8 个 TCP 请求，Xray 只会发出一条实际的 TCP 连接，客户端的 8 个请求全部由这个 TCP 连接传输。\nTIP\n填负数时，如 -1，不加载 mux 模块。\n "},{"uri":"https://badO1a5A90.github.io/config/inbound-protocols/trojan/","title":"Trojan","tags":[],"description":"Project X 的文档.","content":"Trojan 协议\nimportantTrojan 被设计工作在正确配置的加密 TLS 隧道\n InboundConfigurationObject  { \u0026#34;clients\u0026#34;: [ { \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;level\u0026#34;: 0 } ], \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 } ] }  clients: [ ClientObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户ClientObject。\nfallbacks: [ FallbackObject ]\n 一个数组，包含一系列强大的回落分流配置（可选）。\nTIP\nXray 的 Trojan 有完整的 fallbacks 支持，配置方式完全一致。 触发回落的条件也与VLESS类似：首包长度 \u0026lt; 58 或第 57 个字节不为 \u0026lsquo;\\r\u0026rsquo;（因为 Trojan 没有协议版本）或身份认证失败。\n \nClientObject  { \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;level\u0026#34;: 0 }  password: string\n 必填，任意字符串。\nemail: string\n 邮件地址，可选，用于标识用户\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\n"},{"uri":"https://badO1a5A90.github.io/config/outbound-protocols/vmess/","title":"vmess","tags":[],"description":"Project X 的文档.","content":"VMess VMess 是一个加密传输协议，通常作为 Xray 客户端和服务器之间的桥梁。\nimportantVMess 依赖于系统时间，请确保使用 Xray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。\n OutboundConfigurationObject  { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 37192, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;alterId\u0026#34;: 0, \u0026#34;security\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }  vnext：[ ServerObject ]\n 一个数组，包含一组的服务端配置.\n其中每一项是一个服务端配置ServerObject。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 37192, \u0026#34;users\u0026#34;: [] }  address: address\n 服务端地址，支持 IP 地址或者域名。\nport: number\n 服务端监听的端口号, 必填。\nusers: [ UserObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户UserObject。\n\nUserObject  { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34;, \u0026#34;alterId\u0026#34;: 0, \u0026#34;security\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;level\u0026#34;: 0 }  id：string\n VMess 用户的主 ID。必须是一个合法的 UUID。\nalterId：number\n 为了进一步防止被探测，一个用户可以在主 ID 的基础上，再额外生成多个 ID。这里只需要指定额外的 ID 的数量，推荐值为 0 代表启用 VMessAEAD。\n最大值 65535。这个值不能超过服务器端所指定的值。\n不指定的话，默认值是 0。\nTIP\n客户端 AlterID 设置为 0 代表启用 VMessAEAD ；服务端为自动适配，可同时兼容启用和未开启 VMessAEAD 的客户端。\n客户端可通过设置环境变量 Xray_VMESS_AEAD_DISABLED=true 强行禁用 VMessAEAD\n level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nsecurity: \u0026ldquo;aes-128-gcm\u0026rdquo; | \u0026ldquo;chacha20-poly1305\u0026rdquo; | \u0026ldquo;auto\u0026rdquo; | \u0026ldquo;none\u0026rdquo;\n 加密方式，客户端将使用配置的加密方式发送数据，服务器端自动识别，无需配置。\n \u0026quot;aes-128-gcm\u0026quot;：推荐在 PC 上使用 \u0026quot;chacha20-poly1305\u0026quot;：推荐在手机端使用 \u0026quot;auto\u0026quot;：默认值，自动选择（运行框架为 AMD64、ARM64 或 s390x 时为 aes-128-gcm 加密方式，其他情况则为 Chacha20-Poly1305 加密方式） \u0026quot;none\u0026quot;：不加密  TIP\n推荐使用\u0026quot;auto\u0026quot;加密方式，这样可以永久保证安全性和兼容性。\n "},{"uri":"https://badO1a5A90.github.io/config/transports/","title":"传输方式列表","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了目前所有的传输方式及相关的具体配置. 传输方式列表 tcpSettings: TcpObject\n 针对 TCP 连接的配置。\nwsSettings: WebSocketObject\n 针对 WebSocket 连接的配置。\ndsSettings: DomainSocketObject\n 针对 Domain Socket 连接的配置。\nkcpSettings: KcpObject\n 针对 mKCP 连接的配置。\nhttpSettings: HttpObject\n 针对 HTTP/2 连接的配置。\nquicSettings: QuicObject\n 针对 QUIC 连接的配置。\n"},{"uri":"https://badO1a5A90.github.io/caseslip/","title":"大案牍术","tags":[],"description":"Project X 的文档.","content":" 大案牍术记载了 Xray 历史上经过大量研究而破解的迷案, 虽然有些卷宗也许已经迷失在时空里… \n卷宗一览  结案 《大案牍术 卷宗一》\u0026ndash; \u0026ndash; 流量统计功能会使裸协议的 ReadV 和 WriteV 同时失效\n相关卷宗开启各种姿势的统计对各种协议组合性能影响的测试\n  经办@rprx @Arthur Morgan\n 结案 《大案牍术 卷宗三》 \u0026ndash; \u0026ndash; 我们是如何破解Splice性能下降甚至低于Direct之谜的\n相关卷宗HARDWARE NAT\n 经办@rprx @Arthur Morgan\n \n未结案 《大案牍术 卷宗五》 \u0026ndash; \u0026ndash; DS性能之谜?\n相关卷宗DS性能测试\n 经办@rprx @Arthur Morgan\n \n结案 《大案牍术 卷宗六》 \u0026ndash; \u0026ndash; 启动内存之优化优化再优化\n相关卷宗多核服务端单核心负载问题 CPUNum测试\n -- 经办@rprx @AT!Mi @SekiBetu\n \n结案 《大案牍术 卷宗七》 \u0026ndash; \u0026ndash; 一核有难, 多核围观?\n相关卷宗多核服务端单核心负载问题 CPUNum测试\n 经办@rprx @Arthur Morgan @ldmlz\n \n"},{"uri":"https://badO1a5A90.github.io/config/fallback/","title":"Fallback-回落","tags":[],"description":"Project X 的文档.","content":" Fallback 是 Xray 的最强大功能之一, 可有效防止主动探测, 自由配置常用端口多服务共享 \nIn progress\n\nfallback 为 Xray 提供了高强度的防主动探测性, 并且具有独创的首包回落机制.\nfallback 也可以将不同类型的流量根据 path 进行分流, 从而实现一个端口, 多种服务共享.\n目前您可以在使用 VLESS 或者 trojan 协议时, 通过配置 fallbacks 来使用回落这一特, 并且创造出非常丰富的组合玩法.\nfallbacks 配置 \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 } ]  fallbacks: [ FallbackObject ]\n 一个数组，包含一系列强大的回落分流配置。\n\nFallbackObject  { \u0026#34;alpn\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;dest\u0026#34;: 80, \u0026#34;xver\u0026#34;: 0 } fallbacks 是一个数组，这里是其中一个子元素的配置说明。\nfallbacks 项是可选的，只能用于 TCP+TLS 传输组合\n 该项有子元素时，Inbound TLS 需设置 \u0026quot;alpn\u0026quot;:[\u0026quot;http/1.1\u0026quot;]。**  通常，你需要先设置一组 alpn 和 path 均省略或为空的默认回落，然后再按需配置其它分流。\nVLESS 会把 TLS 解密后首包长度 \u0026lt; 18 或协议版本无效、身份认证失败的流量转发到 dest 指定的地址。\n其它传输组合必须删掉 fallbacks 项或所有子元素，此时也不会开启 Fallback，VLESS 会等待读够所需长度，协议版本无效或身份认证失败时，将直接断开连接。\nalpn: string\n 尝试匹配 TLS ALPN 协商结果，空为任意，默认为 \u0026quot;\u0026quot;\n有需要时，VLESS 才会尝试读取 TLS ALPN 协商结果，若成功，输出 info realAlpn = 到日志。 用途：解决了 Nginx 的 h2c 服务不能同时兼容 http/1.1 的问题，Nginx 需要写两行 listen，分别用于 1.1 和 h2c。 注意：fallbacks alpn 存在 \u0026quot;h2\u0026quot; 时，Inbound TLS 需设置 \u0026quot;alpn\u0026quot;:[\u0026quot;h2\u0026quot;,\u0026quot;http/1.1\u0026quot;]，以支持 h2 访问。\nTIP\nFallback 内设置的 \u0026ldquo;alpn\u0026rdquo; 是匹配实际协商出的 ALPN，而 Inbound TLS 设置的 \u0026ldquo;alpn\u0026rdquo; 是握手时可选的 ALPN 列表，两者含义不同。\n path: string\n 尝试匹配首包 HTTP PATH，空为任意，默认为空，非空则必须以 \u0026quot;/\u0026quot; 开头，不支持 h2c。\n智能：有需要时，VLESS 才会尝试看一眼 PATH（不超过 55 个字节；最快算法，并不完整解析 HTTP），若成功，输出 info realPath = 到日志。 用途：分流其它 inbound 的 WebSocket 流量或 HTTP 伪装流量，没有多余处理、纯粹转发流量，实测比 Nginx 反代更强。\n注意：fallbacks 所在入站本身必须是 TCP+TLS，这是分流至其它 WS 入站用的，被分流的入站则无需配置 TLS。\ndest: string | number\n 决定 TLS 解密后 TCP 流量的去向，目前支持两类地址：（该项必填，否则无法启动）\n TCP，格式为 \u0026quot;addr:port\u0026quot;，其中 addr 支持 IPv4、域名、IPv6，若填写域名，也将直接发起 TCP 连接（而不走内置的 DNS）。 Unix domain socket，格式为绝对路径，形如 \u0026quot;/dev/shm/domain.socket\u0026quot;，可在开头加 \u0026quot;@\u0026quot; 代表 abstract，\u0026quot;@@\u0026quot; 则代表带 padding 的 abstract。  若只填 port，数字或字符串均可，形如 80、\u0026quot;80\u0026quot;，通常指向一个明文 http 服务（addr 会被补为 \u0026quot;127.0.0.1\u0026quot;）。\nxver: number\n 发送 PROXY protocol，专用于传递请求的真实来源 IP 和端口，填版本 1 或 2，默认为 0，即不发送。若有需要建议填 1。\n目前填 1 或 2，功能完全相同，只是结构不同，且前者可打印，后者为二进制。Xray 的 TCP 和 WS 入站均已支持接收 PROXY protocol。\nTIP\n若你正在 配置 Nginx 接收 PROXY protocol，除了设置 proxy_protocol 外，还需设置 set_real_ip_from，否则可能会出问题。\n \n补充说明   将匹配到最精确的子元素，与子元素的排列顺序无关。若配置了几个 alpn 和 path 均相同的子元素，则会以最后的为准。 回落分流均是解密后 TCP 层的转发，而不是 HTTP 层，只在必要时检查首包 PATH。 不支持按域名分流。若有此需求，建议前置 Nginx 等并配置 stream SNI 分流。  "},{"uri":"https://badO1a5A90.github.io/config/inbound-protocols/shadowsocks/","title":"Shadowsocks","tags":[],"description":"Project X 的文档.","content":"Shadowsocks 协议，兼容大部分其它版本的实现。\n目前兼容性如下：\n  支持 TCP 和 UDP 数据包转发，其中 UDP 可选择性关闭；\n  推荐的加密方式：\n AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain  不推荐的加密方式:\n AES-256-CFB AES-128-CFB ChaCha20 ChaCha20-IETF    important\u0026ldquo;none\u0026rdquo; 不加密方式下，服务器端不会验证 \u0026ldquo;password\u0026rdquo; 中的密码。为确保安全性, 一般需要加上 TLS 并在传输层使用安全配置，例如 WebSocket 配置较长的 path\n InboundConfigurationObject { \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;aes-256-gcm\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34; }  email: string\n 邮件地址，可选，用于标识用户\nmethod: string\n 必填。\n 推荐的加密方式：  AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain    password: string\n 必填，任意字符串。\nShadowsocks 协议不限制密码长度，但短密码会更可能被破解，建议使用 16 字符或更长的密码。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nnetwork: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo; | \u0026ldquo;tcp,udp\u0026rdquo;\n 可接收的网络协议类型。比如当指定为 \u0026quot;tcp\u0026quot; 时，仅会接收 TCP 流量。默认值为 \u0026quot;tcp\u0026quot;。\n"},{"uri":"https://badO1a5A90.github.io/config/outbound-protocols/trojan/","title":"Trojan","tags":[],"description":"Project X 的文档.","content":"Trojan 协议\nimportantTrojan 被设计工作在正确配置的加密 TLS 隧道\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  servers: [ ServerObject ]\n 一个数组，其中每一项是一个 ServerObject。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 }  address: address\n 服务端地址，支持 IPv4、IPv6 和域名。必填。\nport: number\n 服务端端口，通常与服务端监听的端口相同。\npassword: string\n 密码. 必填，任意字符串。\nemail: string\n 邮件地址，可选，用于标识用户\nflow: string\n trojan 的流控模式.\n目前 trojan 有以下流控模式可选:\n \u0026ldquo;xtls-rprx-origin\u0026rdquo; : 最初的流控方式 \u0026ldquo;xtls-rprx-origin-udp443\u0026rdquo; : 同xtls-rprx-origin, 但是放行了目标为443端口的UDP流量. \u0026ldquo;xtls-rprx-direct\u0026rdquo; : 所有平台皆可使用的典型流控方式 \u0026ldquo;xtls-rprx-direct-udp443\u0026rdquo; : 同xtls-rprx-direct, 但是放行了目标为443端口的UDP流量. \u0026ldquo;xtls-rprx-splice\u0026rdquo; : Linux 平台下最建议使用的流控方式 \u0026ldquo;xtls-rprx-splice-udp443\u0026rdquo; : 同xtls-rprx-splice, 但是放行了目标为443端口的UDP流量.  如果填写了流控模式, 还需将 outbound 的 security 设置成 \u0026ldquo;xtls\u0026rdquo;, 将 \u0026ldquo;tlsSettings\u0026rdquo; 改成 \u0026ldquo;xtlsSettings\u0026rdquo;. 可参考streamSettings设置\nimportantSplice 是 Linux Kernel 提供的函数，系统内核直接转发 TCP，不再经过 Xray 的内存，大大减少了数据拷贝、CPU 上下文切换的次数。\nsplice 模式的的使用限制:\n Linux 环境 inbound为 任意门、Socks、HTTP 等纯净的 TCP 连接, 或 XTLS 模式的inbound outbound 为 VLESS XTLS 或 Trojan XTLS   level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n"},{"uri":"https://badO1a5A90.github.io/config/transport/","title":"传输方式","tags":[],"description":"Project X 的文档.","content":"传输方式（transport）是当前 Xray 节点和其它节点对接的方式。\n传输方式指定了稳定的数据传输的方式。通常来说，一个网络连接的两端需要有对称的传输方式。比如一端用了 WebSocket，那么另一个端也必须使用 WebSocket，否则无法建立连接。\n传输方式（transport）配置有两部分:\n  全局设置（TransportObject）\n  指定inbound/ounbound配置（StreamSettingsObject）。\n指定inbound/ounbound配置时,可以指定每个单独的inbound/ounbound用怎样的方式传输。\n通常来说客户端和服务器对应的inbound和ounbound需要使用同样的传输方式。当inbound/ounbound配置指定了一种传输方式，但没有填写其具体设置时，此传输方式会使用全局配置中的设置。\n  \nTransportObject  TransportObject 对应配置文件的 transport 项。\n{ \u0026#34;transport\u0026#34;: { \u0026#34;tcpSettings\u0026#34;: {}, \u0026#34;kcpSettings\u0026#34;: {}, \u0026#34;wsSettings\u0026#34;: {}, \u0026#34;httpSettings\u0026#34;: {}, \u0026#34;quicSettings\u0026#34;: {}, \u0026#34;dsSettings\u0026#34;: {} } }  tcpSettings: TcpObject\n 针对 TCP 连接的配置。\nkcpSettings: KcpObject\n 针对 mKCP 连接的配置。\nwsSettings: WebSocketObject\n 针对 WebSocket 连接的配置。\nhttpSettings: HttpObject\n 针对 HTTP/2 连接的配置。\nquicSettings: QuicObject\n 针对 QUIC 连接的配置。\ndsSettings: DomainSocketObject\n 针对 Domain Socket 连接的配置。\n\nStreamSettingsObject  StreamSettingsObject 对应inbound/outbound中的 streamSettings 项。每一个 inbound/ounbound 都可以分别配置不同的传输配置，都可以设置 streamSettings 来进行一些传输的配置。\n{ \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;tlsSettings\u0026#34;: {}, \u0026#34;tcpSettings\u0026#34;: {}, \u0026#34;kcpSettings\u0026#34;: {}, \u0026#34;wsSettings\u0026#34;: {}, \u0026#34;httpSettings\u0026#34;: {}, \u0026#34;quicSettings\u0026#34;: {}, \u0026#34;dsSettings\u0026#34;: {}, \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 0, \u0026#34;tcpFastOpen\u0026#34;: false, \u0026#34;tproxy\u0026#34;: \u0026#34;off\u0026#34; } }  network: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;kcp\u0026rdquo; | \u0026ldquo;ws\u0026rdquo; | \u0026ldquo;http\u0026rdquo; | \u0026ldquo;domainsocket\u0026rdquo; | \u0026ldquo;quic\u0026rdquo;\n 连接的数据流所使用的传输方式类型，默认值为 \u0026quot;tcp\u0026quot;\nsecurity: \u0026ldquo;none\u0026rdquo; | \u0026ldquo;tls\u0026rdquo;\n 是否启用传输层加密，支持的选项有\n \u0026quot;none\u0026quot; 表示不加密（默认值） \u0026quot;tls\u0026quot; 表示使用 TLS。 \u0026quot;xtls\u0026quot; 表示使用 XTLS。  tlsSettings: TLSObject\n TLS 配置。TLS 由 Golang 提供，通常情况下TLS协商的结果为使用 TLS 1.3，不支持 DTLS。\nimportant当 security的值指定为\u0026rsquo;xtls\u0026rsquo;时, 需将tlsSettings 修改成为 xtlsSettings, 具体的TLS配置方式不变.\n tcpSettings: TcpObject\n 当前连接的 TCP 配置，仅当此连接使用 TCP 时有效。配置内容与上面的全局配置相同。\nkcpSettings: KcpObject\n 当前连接的 mKCP 配置，仅当此连接使用 mKCP 时有效。配置内容与上面的全局配置相同。\nwsSettings: WebSocketObject\n 当前连接的 WebSocket 配置，仅当此连接使用 WebSocket 时有效。配置内容与上面的全局配置相同。\nhttpSettings: HttpObject\n 当前连接的 HTTP/2 配置，仅当此连接使用 HTTP/2 时有效。配置内容与上面的全局配置相同。\nquicSettings: QUICObject\n 当前连接的 QUIC 配置，仅当此连接使用 QUIC 时有效。配置内容与上面的全局配置相同。\ndsSettings: DomainSocketObject\n 当前连接的 Domain socket 配置，仅当此连接使用 Domain socket 时有效。配置内容与上面的全局配置相同。\nsockopt: SockoptObject\n 透明代理相关的具体配置。\n\nTLSObject  { \u0026#34;serverName\u0026#34;: \u0026#34;xray.com\u0026#34;, \u0026#34;allowInsecure\u0026#34;: false, \u0026#34;alpn\u0026#34;: [ \u0026#34;h2\u0026#34;, \u0026#34;http/1.1\u0026#34; ], \u0026#34;minVersion\u0026#34;: \u0026#34;1.2\u0026#34;, \u0026#34;maxVersion\u0026#34;: \u0026#34;1.3\u0026#34;, \u0026#34;preferServerCipherSuites\u0026#34;: true, \u0026#34;cipherSuites\u0026#34;: \u0026#34;此处填写你需要的加密套件名称,每个套件名称之间用:进行分隔\u0026#34;, \u0026#34;certificates\u0026#34;: [], \u0026#34;disableSystemRoot\u0026#34;: false }  serverName: string\n 指定服务器端证书的域名，在连接由 IP 建立时有用。\n当目标连接由域名指定时，比如在 Socks inbound接收到了域名，或者由 Sniffing 功能探测出了域名，这个域名会自动用于 serverName，无须手动配置。\nalpn: [ string ]\n 一个字符串数组，指定了 TLS 握手时指定的 ALPN 数值。默认值为 [\u0026quot;h2\u0026quot;, \u0026quot;http/1.1\u0026quot;]。\nminVersion: [ string ]\n minVersion为可接受的最小SSL/TLS版本。\nmaxVersion: [ string ]\n maxVersion为可接受的最大SSL/TLS版本。\npreferServerCipherSuites: true | false\n 指示服务器选择客户端最喜欢的密码套件 或 服务器最优选的密码套件。\n如果为true则为使用服务器的最优选的密码套件\ncipherSuites: [ string ]\n CipherSuites用于配置受支持的密码套件列表, 每个套件名称之间用:进行分隔.\n你可以在这里或这里找到golang加密套件的名词和说明\nimportant以上两项配置为非必要选项，正常情况下不影响安全性 在未配置的情况下golang根据设备自动选择. 若不熟悉, 请勿配置此选项, 填写不当引起的问题自行负责\n allowInsecure: true | false\n 是否允许不安全连接（仅用于客户端）。默认值为 false。\n当值为 true 时，Xray 不会检查远端主机所提供的 TLS 证书的有效性。\nimportant出于安全性考虑，这个选项不应该在实际场景中选择true，否则可能遭受中间人攻击。\n disableSystemRoot: true | false\n 是否禁用操作系统自带的 CA 证书。默认值为 false。\n当值为 true 时，Xray 只会使用 certificates 中指定的证书进行 TLS 握手。当值为 false 时，Xray 只会使用操作系统自带的 CA 证书进行 TLS 握手。\ncertificates: [ CertificateObject ]\n 证书列表，其中每一项表示一个证书（建议 fullchain）。\nTIP\n如果要在 ssllibs 或者 myssl 获得 A/A+ 等级的评价, 请参考这里.\n CertificateObject { \u0026#34;usage\u0026#34;: \u0026#34;encipherment\u0026#34;, \u0026#34;certificateFile\u0026#34;: \u0026#34;/path/to/certificate.crt\u0026#34;, \u0026#34;keyFile\u0026#34;: \u0026#34;/path/to/key.key\u0026#34;, \u0026#34;certificate\u0026#34;: [ \u0026#34;-----BEGIN CERTIFICATE-----\u0026#34;, \u0026#34;MIICwDCCAaigAwIBAgIRAO16JMdESAuHidFYJAR/7kAwDQYJKoZIhvcNAQELBQAw\u0026#34;, \u0026#34;ADAeFw0xODA0MTAxMzU1MTdaFw0xODA0MTAxNTU1MTdaMAAwggEiMA0GCSqGSIb3\u0026#34;, \u0026#34;DQEBAQUAA4IBDwAwggEKAoIBAQCs2PX0fFSCjOemmdm9UbOvcLctF94Ox4BpSfJ+\u0026#34;, \u0026#34;3lJHwZbvnOFuo56WhQJWrclKoImp/c9veL1J4Bbtam3sW3APkZVEK9UxRQ57HQuw\u0026#34;, \u0026#34;OzhV0FD20/0YELou85TwnkTw5l9GVCXT02NG+pGlYsFrxesUHpojdl8tIcn113M5\u0026#34;, \u0026#34;pypgDPVmPeeORRf7nseMC6GhvXYM4txJPyenohwegl8DZ6OE5FkSVR5wFQtAhbON\u0026#34;, \u0026#34;OAkIVVmw002K2J6pitPuJGOka9PxcCVWhko/W+JCGapcC7O74palwBUuXE1iH+Jp\u0026#34;, \u0026#34;noPjGp4qE2ognW3WH/sgQ+rvo20eXb9Um1steaYY8xlxgBsXAgMBAAGjNTAzMA4G\u0026#34;, \u0026#34;A1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAA\u0026#34;, \u0026#34;MA0GCSqGSIb3DQEBCwUAA4IBAQBUd9sGKYemzwPnxtw/vzkV8Q32NILEMlPVqeJU\u0026#34;, \u0026#34;7UxVgIODBV6A1b3tOUoktuhmgSSaQxjhYbFAVTD+LUglMUCxNbj56luBRlLLQWo+\u0026#34;, \u0026#34;9BUhC/ow393tLmqKcB59qNcwbZER6XT5POYwcaKM75QVqhCJVHJNb1zSEE7Co7iO\u0026#34;, \u0026#34;6wIan3lFyjBfYlBEz5vyRWQNIwKfdh5cK1yAu13xGENwmtlSTHiwbjBLXfk+0A/8\u0026#34;, \u0026#34;r/2s+sCYUkGZHhj8xY7bJ1zg0FRalP5LrqY+r6BckT1QPDIQKYy615j1LpOtwZe/\u0026#34;, \u0026#34;d4q7MD/dkzRDsch7t2cIjM/PYeMuzh87admSyL6hdtK0Nm/Q\u0026#34;, \u0026#34;-----END CERTIFICATE-----\u0026#34; ], \u0026#34;key\u0026#34;: [ \u0026#34;-----BEGIN RSA PRIVATE KEY-----\u0026#34;, \u0026#34;MIIEowIBAAKCAQEArNj19HxUgoznppnZvVGzr3C3LRfeDseAaUnyft5SR8GW75zh\u0026#34;, \u0026#34;bqOeloUCVq3JSqCJqf3Pb3i9SeAW7Wpt7FtwD5GVRCvVMUUOex0LsDs4VdBQ9tP9\u0026#34;, \u0026#34;GBC6LvOU8J5E8OZfRlQl09NjRvqRpWLBa8XrFB6aI3ZfLSHJ9ddzOacqYAz1Zj3n\u0026#34;, \u0026#34;jkUX+57HjAuhob12DOLcST8np6IcHoJfA2ejhORZElUecBULQIWzjTgJCFVZsNNN\u0026#34;, \u0026#34;itieqYrT7iRjpGvT8XAlVoZKP1viQhmqXAuzu+KWpcAVLlxNYh/iaZ6D4xqeKhNq\u0026#34;, \u0026#34;IJ1t1h/7IEPq76NtHl2/VJtbLXmmGPMZcYAbFwIDAQABAoIBAFCgG4phfGIxK9Uw\u0026#34;, \u0026#34;qrp+o9xQLYGhQnmOYb27OpwnRCYojSlT+mvLcqwvevnHsr9WxyA+PkZ3AYS2PLue\u0026#34;, \u0026#34;C4xW0pzQgdn8wENtPOX8lHkuBocw1rNsCwDwvIguIuliSjI8o3CAy+xVDFgNhWap\u0026#34;, \u0026#34;/CMzfQYziB7GlnrM6hH838iiy0dlv4I/HKk+3/YlSYQEvnFokTf7HxbDDmznkJTM\u0026#34;, \u0026#34;aPKZ5qbnV+4AcQfcLYJ8QE0ViJ8dVZ7RLwIf7+SG0b0bqloti4+oQXqGtiESUwEW\u0026#34;, \u0026#34;/Wzi7oyCbFJoPsFWp1P5+wD7jAGpAd9lPIwPahdr1wl6VwIx9W0XYjoZn71AEaw4\u0026#34;, \u0026#34;bK4xUXECgYEA3g2o9WqyrhYSax3pGEdvV2qN0VQhw7Xe+jyy98CELOO2DNbB9QNJ\u0026#34;, \u0026#34;8cSSU/PjkxQlgbOJc8DEprdMldN5xI/srlsbQWCj72wXxXnVnh991bI2clwt7oYi\u0026#34;, \u0026#34;pcGZwzCrJyFL+QaZmYzLxkxYl1tCiiuqLm+EkjxCWKTX/kKEFb6rtnMCgYEAx0WR\u0026#34;, \u0026#34;L8Uue3lXxhXRdBS5QRTBNklkSxtU+2yyXRpvFa7Qam+GghJs5RKfJ9lTvjfM/PxG\u0026#34;, \u0026#34;3vhuBliWQOKQbm1ZGLbgGBM505EOP7DikUmH/kzKxIeRo4l64mioKdDwK/4CZtS7\u0026#34;, \u0026#34;az0Lq3eS6bq11qL4mEdE6Gn/Y+sqB83GHZYju80CgYABFm4KbbBcW+1RKv9WSBtK\u0026#34;, \u0026#34;gVIagV/89moWLa/uuLmtApyEqZSfn5mAHqdc0+f8c2/Pl9KHh50u99zfKv8AsHfH\u0026#34;, \u0026#34;TtjuVAvZg10GcZdTQ/I41ruficYL0gpfZ3haVWWxNl+J47di4iapXPxeGWtVA+u8\u0026#34;, \u0026#34;eH1cvgDRMFWCgE7nUFzE8wKBgGndUomfZtdgGrp4ouLZk6W4ogD2MpsYNSixkXyW\u0026#34;, \u0026#34;64cIbV7uSvZVVZbJMtaXxb6bpIKOgBQ6xTEH5SMpenPAEgJoPVts816rhHdfwK5Q\u0026#34;, \u0026#34;8zetklegckYAZtFbqmM0xjOI6bu5rqwFLWr1xo33jF0wDYPQ8RHMJkruB1FIB8V2\u0026#34;, \u0026#34;GxvNAoGBAM4g2z8NTPMqX+8IBGkGgqmcYuRQxd3cs7LOSEjF9hPy1it2ZFe/yUKq\u0026#34;, \u0026#34;ePa2E8osffK5LBkFzhyQb0WrGC9ijM9E6rv10gyuNjlwXdFJcdqVamxwPUBtxRJR\u0026#34;, \u0026#34;cYTY2HRkJXDdtT0Bkc3josE6UUDvwMpO0CfAETQPto1tjNEDhQhT\u0026#34;, \u0026#34;-----END RSA PRIVATE KEY-----\u0026#34; ] }  usage: \u0026ldquo;encipherment\u0026rdquo; | \u0026ldquo;verify\u0026rdquo; | \u0026ldquo;issue\u0026rdquo;\n 证书用途，默认值为 \u0026quot;encipherment\u0026quot;。\n \u0026quot;encipherment\u0026quot;：证书用于 TLS 认证和加密。 \u0026quot;verify\u0026quot;：证书用于验证远端 TLS 的证书。当使用此项时，当前证书必须为 CA 证书。 \u0026quot;issue\u0026quot;：证书用于签发其它证书。当使用此项时，当前证书必须为 CA 证书。  TIP 1\n在 Windows 平台上可以将自签名的 CA 证书安装到系统中，即可验证远端 TLS 的证书。\n TIP 2\n当有新的客户端请求时，假设所指定的 serverName 为 \u0026quot;xray.com\u0026quot;，Xray 会先从证书列表中寻找可用于 \u0026quot;xray.com\u0026quot; 的证书，如果没有找到，则使用任一 usage 为 \u0026quot;issue\u0026quot; 的证书签发一个适用于 \u0026quot;xray.com\u0026quot; 的证书，有效期为一小时。并将新的证书加入证书列表，以供后续使用。\n TIP 3\n当 certificateFile 和 certificate 同时指定时，Xray 优先使用 certificateFile。keyFile 和 key 也一样。\n TIP 4\n当 usage 为 \u0026quot;verify\u0026quot; 时，keyFile 和 key 可均为空。\n TIP 5\n使用 xray tls cert 可以生成自签名的 CA 证书。\n TIP 6\n如已经拥有一个域名, 可以使用工具便捷的获取免费第三方证书,如acme.sh\n certificateFile: string\n 证书文件路径，如使用 OpenSSL 生成，后缀名为 .crt。\ncertificate: [ string ]\n 一个字符串数组，表示证书内容，格式如样例所示。certificate 和 certificateFile 二者选一。\nkeyFile: string\n 密钥文件路径，如使用 OpenSSL 生成，后缀名为 .key。目前暂不支持需要密码的 key 文件。\nkey: [ string ]\n 一个字符串数组，表示密钥内容，格式如样例如示。key 和 keyFile 二者选一。\n\nSockoptObject  { \u0026#34;mark\u0026#34;: 0, \u0026#34;tcpFastOpen\u0026#34;: false, \u0026#34;tproxy\u0026#34;: \u0026#34;off\u0026#34; }  mark: number\n 一个整数。当其值非零时，在ountbound连接以此数值上标记 SO_MARK。\n 仅适用于 Linux 系统。 需要 CAP_NET_ADMIN 权限。  tcpFastOpen: true | false\n 是否启用 TCP Fast Open。\n当其值为 true 时，强制开启 TFO；当其值为 false 时，强制关闭 TFO；当此项不存在时，使用系统默认设置。 可用于inbound/ountbound。\n 仅在以下版本（或更新版本）的操作系统中可用:  Windows 10 (1604) Mac OS 10.11 / iOS 9 Linux 3.16：系统已默认开启，无需配置。    tproxy: \u0026ldquo;redirect\u0026rdquo; | \u0026ldquo;tproxy\u0026rdquo; | \u0026ldquo;off\u0026rdquo;\n 是否开启透明代理（仅适用于 Linux）。\n \u0026quot;redirect\u0026quot;：使用 Redirect 模式的透明代理。支持所有基于 IPv4/6 的 TCP 和 UDP 连接。 \u0026quot;tproxy\u0026quot;：使用 TProxy 模式的透明代理。支持所有基于 IPv4/6 的 TCP 和 UDP 连接。 \u0026quot;off\u0026quot;：关闭透明代理。  透明代理需要 Root 或 CAP_NET_ADMIN 权限。\nimportant当 Dokodemo-door 中指定了 followRedirect为true，且 Sockopt设置中的tproxy 为空时，Sockopt设置中的tproxy 的值会被设为 \u0026quot;redirect\u0026quot;。\n "},{"uri":"https://badO1a5A90.github.io/qa/about/","title":"关于Xray","tags":[],"description":"Project X 的文档.","content":" Q: XXX功能什么时候出来呀!康明宋\n Q: 为什么会开发 Xray ?兴趣使然\n Q: Xray收钱吗? 可以按我的要求定制吗?Xray 不沾钱,这是个兴趣使然的项目.\nXray 不接受定制, 只根据大家的需求进行兴趣使然的开发.\n Q: XXX也是你们开发的吗?请明辨您获取资源的来源, 小心使用, 谨防蜜罐\n我们的开发均托管在 github, 不在project X 仓库的, 都不属于 project X 开发.\n当然也有很多大佬支持着 Xray 的开发和完善了生态圈, 请见这里.\n我们也欢迎所有人一起来完善 Xray.\n Q: Xray和v2ray是什么关系啊?禁忌の歷史迷局\nXray 的核心创新是\n VLESS 协议 回落分流 , 防主动探测, 强大而且灵活的分流. XTLS，旨在尽可能减少数据流转过程中多余的资源使用（表现为性能大幅提升，CPU 占用大幅降低/网速和延迟可以接近硬件的极限） Xray 保持着活跃的开发与更新, 拒绝搞技术壁垒而保持亲和力, 目标是人人会用. Xray 每周都会有新的特性加入或是历史问题的解决, 更多功能建议关注更新的 release notes.  因为各种各样的原因，xray 与 v2ray 选择了不同的发展路线，并独立分支做维护。（v2ray v4.33.0 起移除了 XTLS 的支持，但保留了 VLESS 协议支持）\n至于实际效果，每个人的软件、硬件、线路都不一样，建议自行尝试测试。\n \n"},{"uri":"https://badO1a5A90.github.io/links/","title":"常用链接","tags":[],"description":"Project X 的文档.","content":"安装脚本   Linux Script  Xray-install Xray-script 感谢@kirin   Docker  teddysun/xray 感谢@秋水逸冰 Xray-docker   One Click  ProxySU 感谢@ProxySu Xray-agent 感谢@mack-a   Magisk  Xray4Magisk 感谢@子曦曦 Xray_For_Magisk 感谢@E7KMbb    \n配置模板  所有的模板请传送至: Xray-examples\n包含了各种用法示范的终极配置: VLESS-TCP-XTLS-WHATEVER\n\n图形化客户端   OpenWrt  PassWall Hello World ShadowSocksR Plus+   Windows  v2rayN Qv2ray   Android  v2rayNG Kitsunebi   iOS / Mac  Shadowrocket    \nUUID 生成器  第三方的 UUID 生成器 uuidgenerator.net\n"},{"uri":"https://badO1a5A90.github.io/config/outbound-protocols/shadowsocks/","title":"Shadowsocks","tags":[],"description":"Project X 的文档.","content":"Shadowsocks 协议，兼容大部分其它版本的实现。\n目前兼容性如下：\n  支持 TCP 和 UDP 数据包转发，其中 UDP 可选择性关闭；\n  推荐的加密方式：\n AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain  不推荐的加密方式:\n AES-256-CFB AES-128-CFB ChaCha20 ChaCha20-IETF    important\u0026ldquo;none\u0026rdquo; 不加密方式下，服务器端不会验证 \u0026ldquo;password\u0026rdquo; 中的密码。为确保安全性, 一般需要加上 TLS 并在传输层使用安全配置，例如 WebSocket 配置较长的 path\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;method\u0026#34;: \u0026#34;加密方式\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  servers: [ServerObject]\n 一个数组，代表一组 Shadowsocks 服务端设置, 其中每一项是一个 ServerObject。\n\nServerObject  { \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;method\u0026#34;: \u0026#34;加密方式\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;level\u0026#34;: 0 }  email: string\n 邮件地址，可选，用于标识用户\naddress: address\n Shadowsocks 服务端地址，支持 IPv4、IPv6 和域名。必填。\nport: number\n Shadowsocks 服务端端口。必填。\nmethod: string\n 必填。\n 推荐的加密方式：  AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain    password: string\n 必填。任意字符串。\nShadowsocks 协议不限制密码长度，但短密码会更可能被破解，建议使用 16 字符或更长的密码。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n"},{"uri":"https://badO1a5A90.github.io/config/stats/","title":"统计信息","tags":[],"description":"Project X 的文档.","content":"用于配置 Xray 流量数据的统计。\nStatsObject StatsObject 对应配置文件的 stats 项。\n{ \u0026#34;stats\u0026#34;: {} } 目前统计信息不需要任何参数，只要 StatsObject 项存在，内部的统计即会开启。\n开启了统计以后, 只需在 Policy 中开启对应的项，就可以统计对应的数据。\n\n获取统计信息  可以用 xray api 的相关命令获取统计信息.\n目前已有的统计信息如下：\n  用户数据\n  user\u0026gt;\u0026gt;\u0026gt;[email]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;uplink\n特定用户的上行流量，单位字节。\n  user\u0026gt;\u0026gt;\u0026gt;[email]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;downlink\n特定用户的下行流量，单位字节。\n  TIP\n如果对应用户没有指定 Email，则不会开启统计。\n   全局数据\n  inbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;uplink\n特定inbound的上行流量，单位字节。\n  inbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;downlink\n特定inbound的下行流量，单位字节。\n  outbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;uplink\n特定outbound的上行流量，单位字节。\n  outbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;downlink\n特定outbound的下行流量，单位字节。\n    "},{"uri":"https://badO1a5A90.github.io/config/xtls/","title":"XTLS","tags":[],"description":"Project X 的文档.","content":" XTLS 是 Xray 的原创黑科技, 也是使 Xray 性能一骑绝尘的核心动力 \nIn progress\n"},{"uri":"https://badO1a5A90.github.io/config/reverse/","title":"反向代理","tags":[],"description":"Project X 的文档.","content":"反向代理可以把服务器端的流量向客户端转发，即逆向流量转发。\n反向代理的大致工作原理如下:\n 假设在主机 A 中有一个网页服务器，这台主机没有公网 IP，无法在公网上直接访问。另有一台主机 B，它可以由公网访问。现在我们需要把 B 作为入口，把流量从 B 转发到 A。 在主机 A 中配置 Xray，称为bridge，在 B 中也配置 Xray，称为 portal。 bridge 会向 portal 主动建立连接，此连接的目标地址可以自行设定。portal 会收到两种连接，一是由 bridge 发来的连接，二是公网用户发来的连接。portal 会自动将两类连接合并。于是 bridge 就可以收到公网流量了。 bridge 在收到公网流量之后，会将其原封不动地发给主机 A 中的网页服务器。当然，这一步需要路由的协作。 bridge 会根据流量的大小进行动态的负载均衡。  TIP\n反向代理默认已开启 Mux，请不要在其用到的outbound上再次开启 Mux。\n 反向代理功能尚处于测试阶段，可能会有一些问题。\n \nReverseObject  ReverseObject 对应配置文件的 reverse 项。\n{ \u0026#34;reverse\u0026#34;: { \u0026#34;bridges\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; } ], \u0026#34;portals\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;portal\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; } ] } }  bridges: [BridgeObject]\n 数组，每一项表示一个 bridge。每个 bridge 的配置是一个 BridgeObject。\nportals: [PortalObject]\n 数组，每一项表示一个 portal。每个 portal 的配置是一个 PortalObject。\n\nBridgeObject  { \u0026#34;tag\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; }  tag: string\n 所有由 bridge 发出的连接，都会带有这个标识。可以在 路由配置 中使用 inboundTag 进行识别。\ndomain: string\n 指定一个域名，bridge 向 portal 建立的连接，都会使用这个域名进行发送。\n这个域名只作为 bridge 和 portal 的通信用途，不必真实存在。\n\nPortalObject  { \u0026#34;tag\u0026#34;: \u0026#34;portal\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; }  tag: string\n portal 的标识。在 路由配置 中使用 outboundTag 将流量转发到这个 portal。\ndomain: string\n 一个域名。当 portal 接收到流量时，如果流量的目标域名是此域名，则 portal 认为当前连接上 bridge 发来的通信连接。而其它流量则会被当成需要转发的流量。portal 所做的工作就是把这两类连接进行识别并拼接。\nTIP\n一个 Xray 既可以作为 bridge，也可以作为 portal，也可以同时两者，以适用于不同的场景需要。\n \n完整配置样例  TIP\n在运行过程中，建议先启用 bridge，再启用 portal。\n bridge配置  bridge 通常需要两个outbound，一个用于连接 portal，另一个用于发送实际的流量。也就是说，你需要用路由区分两种流量。\n反向代理配置:\n{ \u0026#34;bridges\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; } ] } outbound:\n{ \u0026#34;tag\u0026#34;: \u0026#34;out\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;redirect\u0026#34;: \u0026#34;127.0.0.1:80\u0026#34; // 将所有流量转发到网页服务器 } }, { \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;portal 的 IP 地址\u0026#34;, \u0026#34;port\u0026#34;: 1024, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34; } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;interconn\u0026#34; } 路由配置:\n\u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;bridge\u0026#34; ], \u0026#34;domain\u0026#34;: [ \u0026#34;full:test.xray.com\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;interconn\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;bridge\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;out\u0026#34; } ] } \nportal配置  portal 通常需要两个inbound，一个用于接收 bridge 的连接，另一个用于接收实际的流量。同时你也需要用路由区分两种流量。\n反向代理配置:\n{ \u0026#34;portals\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;portal\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; // 必须和 bridge 的配置一样 } ] } inbound:\n{ \u0026#34;tag\u0026#34;: \u0026#34;external\u0026#34;, \u0026#34;port\u0026#34;: 80, // 开放 80 端口，用于接收外部的 HTTP 访问 \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 80, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34; } }, { \u0026#34;port\u0026#34;: 1024, // 用于接收 bridge 的连接 \u0026#34;tag\u0026#34;: \u0026#34;interconn\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;27848739-7e62-4138-9fd3-098a63964b6b\u0026#34; } ] } } 路由配置:\n\u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;external\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;portal\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;interconn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;portal\u0026#34; } ] } "},{"uri":"https://badO1a5A90.github.io/config/env/","title":"环境变量","tags":[],"description":"Project X 的文档.","content":"Xray 提供以下环境变量以供修改 Xray 的一些底层配置。\n\nXTLS 信息显示  VLESS   名称：xray.vless.xtls.show 或 XRAY_VLESS_XTLS_SHOW。 默认值：\u0026quot;\u0026quot;。  使用 VLESS 协议时,设置此环境变量为 true 时, 会在终端或日志中输出 XTLS 的相关信息.\nTIP\n可打开此环境变量并根据是否有输出 XTLS 相关信息, 来确定 XTLS 是否成功被应用.\n TROJAN   名称：xray.trojan.xtls.show 或 XRAY_TROJAN_XTLS_SHOW。 默认值：\u0026quot;\u0026quot;。  使用 trojan 协议时, 设置此环境变量为 true 时, 会在终端或日志中输出 XTLS 的相关信息.\nTIP\n可打开此环境变量并根据是否有输出 XTLS 相关信息, 来确定 XTLS 是否成功被应用.\n \n资源文件路径   名称：xray.location.asset 或 XRAY_LOCATION_ASSET。 默认值：和 Xray 文件同路径。  这个环境变量指定了一个文件夹位置，这个文件夹应当包含 geoip.dat 和 geosite.dat 文件。\n\n配置文件位置   名称：xray.location.config 或 XRAY_LOCATION_CONFIG。 默认值：和 Xray 文件同路径。  这个环境变量指定了一个文件夹位置，这个文件夹应当包含 config.json 文件。\n\n多配置目录   名称：xray.location.confdir 或 XRAY_LOCATION_CONFDIR。 默认值：\u0026quot;\u0026quot;。  这个目录内的 .json 文件会按文件名顺序读取，作为多配置选项。\n\n"},{"uri":"https://badO1a5A90.github.io/config/multiple_config/","title":"多文件配置","tags":[],"description":"Project X 的文档.","content":"Xray 程序支持使用多个配置文件。\n多配置文件的主要作用在于分散不同作用模块配置，便于管理和维护。\n该功能主要考虑是为了丰富 Xray 的生态链，比如对于 GUI 的客户端，一般只实现节点选择等固定的功能，对于太复杂的配置难以图形化实现；只需留一个 confdir 的自定义配置目录供配置复杂的功能；对于服务器的部署脚本，只需往 confdir 添加文件即可实现配置多种协议。\n多文件启动  TIP\n启动信息中会提示依次读入的每个配置文件，留意启动信息是否符合你预设的顺序。\n $ xray run -confdir /etc/xray/confs 也可使用 环境变量 Xray.location.confdir 或 Xray_LOCATION_CONFDIR 指定 confdir。\n参数 -confdir 的作用优先于环境变量，如果参数指定了有效的目录则不再读取环境变量中的路径。\n\n规则说明  普通对象（{}）  在 json 的顶级对象当中，后者覆盖或补充前者。\n比如：\n base.json  { \u0026#34;log\u0026#34;: {}, \u0026#34;api\u0026#34;: {}, \u0026#34;dns\u0026#34;: {}, \u0026#34;stats\u0026#34;: {}, \u0026#34;policy\u0026#34;: {}, \u0026#34;transport\u0026#34;: {}, \u0026#34;routing\u0026#34;: {}, \u0026#34;inbounds\u0026#34;: [] }  outbounds.json  { \u0026#34;outbounds\u0026#34;: [] } 以多配置启动 Xray：\n$ xray run -confdir /etc/xray/confs 这两个配置文件的就等效于合成一起的整配置。当需要修改出口节点，只需要修改 outbounds.json 内容。\n如果需要改编日志 log 的级别，也不需要改 base.json，只需后续增加一个配置：\n debuglog.json  { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;debug\u0026#34; } } 启动顺序放置在 base 后，即可输出 debug 级别的日志\n\n数组（[]）  在 json 配置中的inbounds和outbounds是数组结构，他们有特殊的规则：\n 当配置中的数组元素有 2 或以上，覆盖前者的 inbounds/oubounds； 当配置中的数组元素只有 1 个时，查找原有tag相同的元素进行覆盖；若无法找到：  对于 inbounds，添加至最后（inbounds 内元素顺序无关） 对于 outbounds，添加至最前（outbounds 默认首选出口）；但如果文件名含有 tail（大小写均可），添加至最后。    借助多配置，可以很方便为原有的配置添加不同协议的 inbound，而不必修改原有配置。\n以下例子不是有效配置，只为展示上述规则。\n 000.json  { \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;socks\u0026#34;, \u0026#34;port\u0026#34;: 1234 } ] }  001.json  { \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;http\u0026#34; } ] }  002.json  { \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;socks\u0026#34;, \u0026#34;port\u0026#34;: 4321 } ] } 三个配置将会合成为：\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;socks\u0026#34;, \u0026#34;port\u0026#34;: 4321 // \u0026lt;--- 002顺序在000后，因此覆盖tag为socks的inbound端口为4321 }, { \u0026#34;protocol\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;http\u0026#34; } ] } \n推荐的多文件列表  执行：\nfor BASE in 00_log 01_api 02_dns 03_routing 04_policy 05_inbounds 06_outbounds 07_transport 08_stats 09_reverse; do echo \u0026#39;{}\u0026#39; \u0026gt; \u0026#34;/etc/Xray/$BASE.json\u0026#34;; done 或\nfor BASE in 00_log 01_api 02_dns 03_routing 04_policy 05_inbounds 06_outbounds 07_transport 08_stats 09_reverse; do echo \u0026#39;{}\u0026#39; \u0026gt; \u0026#34;/usr/local/etc/Xray/$BASE.json\u0026#34;; done . ├── 00_log.json ├── 01_api.json ├── 02_dns.json ├── 03_routing.json ├── 04_policy.json ├── 05_inbounds.json ├── 06_outbounds.json ├── 07_transport.json ├── 08_stats.json └── 09_reverse.json 0 directories, 10 files "},{"uri":"https://badO1a5A90.github.io/404.html","title":"Whoops! Page not found","tags":[],"description":"This is a 404 page","content":"That page can\u0026rsquo;t be found.\nOur latest content is on the homepage.\nPhoto by Aron Visuals on Unsplash"},{"uri":"https://badO1a5A90.github.io/","title":"","tags":[],"description":"","content":"  不 畏 浮 云 遮 望 眼 · 金 睛 如 炬 耀 苍 穹\nK E E P R I D I N G / N E V E R L O O K B A C K\n 由此开始    极速协议 \n原创 VLESS 轻量协议 摆脱冗余加密\n原创 XTLS 及 Direct/Splice流控 释放CPU算力\n 自由回落 \n完善的回落机制 有效防止主动探测\n自由配置常用端口 多服务共享\n 超低占用 \n适合 OpenWRT RaspberryPi 等\n各种精简设备皆可使用\n  \n跨平台 \nWindows, macOS, Linux, iOS, Android\u0026hellip; \n各种平台皆可用\n 强兼容 \n完整兼容 v2ray-core 配置文件\n完整兼容 v2ray-core API 调用\n 亲和力 \n活跃的社区讨论及贡献\nMPL 2.0 开源许可协议\n    \n\n"}]